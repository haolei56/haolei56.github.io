<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝暮惜</title>
  
  <subtitle>浮生三千</subtitle>
  <link href="http://haolei56.github.io/atom.xml" rel="self"/>
  
  <link href="http://haolei56.github.io/"/>
  <updated>2023-05-21T14:00:44.884Z</updated>
  <id>http://haolei56.github.io/</id>
  
  <author>
    <name>HL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>146. LRU缓存</title>
    <link href="http://haolei56.github.io/2023/052110571.html"/>
    <id>http://haolei56.github.io/2023/052110571.html</id>
    <published>2023-05-21T09:19:12.218Z</published>
    <updated>2023-05-21T14:00:44.884Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<br>实现 LRUCache 类：<br>LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存<br>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。<br>void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。<br>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。</p><p><strong>分析：</strong>我们采用一个链表list&lt;pair&lt;int, int&gt;&gt; 来储存信息的key 和value，链表的链接顺序即为最近使用的新旧顺序，最新的信息在链表头节点。同时我们需要一个嵌套着链表的迭代器的un-ordered_map&lt;int, list&lt;pair&lt;int, int»::iterator&gt; 进行快速搜索，存迭代器的原因是方便调用链表的splice 函数来直接更新查找成功（cash hit）时的信息，即把迭代器对应的节点移动为链表的头节点。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class LRUCache{    unordered_map<int, list<pair<int, int>>::iterator> hash;    list<pair<int, int>> cache;    int size;public:    LRUCache(int capacity) : size(capacity) {}    int get(int key){        auto it = hash.find(key);        if (it == hash.end()){            return -1;        }        cache.splice(cache.begin(), cache, it->second);        return it->second->second;    }    void put(int key, int value){        auto it = hash.find(key);        if (it != hash.end()){            it->second->second = value;            cache.splice(cache.begin(), cache, it->second);        }        cache.insert(cache.begin(), make_pair(key, value));        hash[key] = cache.begin();        if (cache.size() > size){            hash.erase(cache.back().first);            cache.pop_back();        }    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：链表的 <code>splice</code> 函数是 C++ STL 提供的一个成员函数，用于将一个链表中的一段节点（连续的一段）移动到另一个链表的某个位置。</p><pre class="line-numbers language-c++"><code class="language-c++">void splice (const_iterator pos, list& x);void splice (const_iterator pos, list&& x);void splice (const_iterator pos, list& x, const_iterator it);void splice (const_iterator pos, list&& x, const_iterator it);void splice (const_iterator pos, list& x, const_iterator first, const_iterator last);void splice (const_iterator pos, list&& x, const_iterator first, const_iterator last);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中，<code>pos</code> 是指定目标链表中插入位置的迭代器；<code>x</code> 是源链表；<code>it</code> 是源链表中需要移动的节点位置的迭代器，<code>first</code> 和 <code>last</code> 则是源链表中需要移动的节点的起始和终止位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。&lt;br&gt;实现 LRUCache 类：&lt;br&gt;LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存&lt;br&gt;i</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="LRU" scheme="http://haolei56.github.io/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://haolei56.github.io/2023/052161809.html"/>
    <id>http://haolei56.github.io/2023/052161809.html</id>
    <published>2023-05-21T09:16:44.110Z</published>
    <updated>2023-05-21T14:00:44.988Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并查集（union-find, 或disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。</strong>假设存在n 个节点，我们先将所有节点的父亲标为自己；每次要连接节点i 和j 时，我们可以将i 的父亲标为j；每次要查询两个节点是否相连时，我们可以查找i 和j 的祖先是否最终为同一个人。</p><p><img src="https://s2.loli.net/2023/05/21/YKkyCAOFjfRV8TZ.jpg" alt="并查集"></p><p>并查集样例，其中union 操作可以将两个集合连在一起，find 操作可以查找给定节点的祖先，并且如果可以的话，将集合的层数&#x2F;高度降低</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;并查集（union-find, 或disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。&lt;/strong&gt;假设存在n 个节点，我们先将所有节点的父亲标为自己；每次要连接节点i 和j 时，我们可以将i 的父亲标为j；每次要查询两</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Union-Find" scheme="http://haolei56.github.io/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>696. 计数二进制子串</title>
    <link href="http://haolei56.github.io/2023/052125920.html"/>
    <id>http://haolei56.github.io/2023/052125920.html</id>
    <published>2023-05-21T09:16:44.105Z</published>
    <updated>2023-05-21T14:00:44.944Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。重复出现（不同位置）的子串也要统计它们出现的次数。</p><p>输入：s &#x3D; “00110011”<br>输出：6<br>解释：6 个子串满足具有相同数量的连续 1 和 0 ：”0011”、”01”、”1100”、”10”、”0011” 和 “01”<br>注意，一些重复出现的子串（不同位置）要统计它们出现的次数。<br>另外，”00110011” 不是有效的子串，因为所有的 0（还有 1 ）没有组合在一起。</p><p><strong>分析：</strong>从左往右遍历数组，记录和当前位置数字相同且连续的长度，以及其之前连续的不同数字的长度。举例来说，对于00110 的最后一位，我们记录的相同数字长度是1，因为只有一个连续0；我们记录的不同数字长度是2，因为在0 之前有两个连续的1。若不同数字的连续长度大于等于当前数字的连续长度，则说明存在一个且只存在一个以当前数字结尾的满足条件的子字符串。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">int countBinarySubstrings(string s){    int pre = 0, cur = 1, count = 0;    for (int i = 1; i < s.length(); ++i){        if (s[i] == s[i - 1]){            ++cur;        }        else{            pre = cur;            cur = 1;        }        if (pre >= cur){            ++count;        }    }    return count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++"><code class="language-C++">class UF{    vector<int> id;//id数组用于记录每个元素的父节点，初始时，每个元素都是独立的，调用connect函数连接起来    vector<int> size;//记录树的“重量”,即节点数,⽬的是让connect后树依然拥有平衡性，⽽不会退化成链表，影响操作效率。public:    UF(int n) : id(n),size(n){        for (int i = 0; i < n; i++) {            size[i] = 1;        }        iota(id.begin(), id.end(), 0); // iotac++标准库函数，可以把数组初始化为0到n-1，    }        int find(int p){//用于查找元素p所在的连通分量的代表元素，即它的根节点。        while (p != id[p]){            // 进⾏路径压缩，，保证任意树的⾼度保持在常数，使得connection 和isconnected API 时间复杂度为 O(1)。            id[p] =id[id[p]];            p = id[p];        }        return p;    }        void connect(int p, int q){//用于将p和q所在的两个连通分量合并成一个连通分量。        int rootP = find(p);    int rootQ = find(q);    if (rootP == rootQ){            return;        }        // ⼩树接到⼤树下⾯，较平衡    if (size[rootP] > size[rootQ]) {        id[rootQ] = rootP;        size[rootP] += size[rootQ];    } else {        id[rootP] = rootQ;        size[rootQ] += size[rootP];    }    }        bool isConnected(int p, int q){//函数可以利用find函数判断两个元素是否属于同一个连通分量。        return find(p) == find(q);    }};class Solution{public:    vector<int> findRedundantConnection(vector<vector<int>> &edges){        int n = edges.size();        UF uf(n + 1);        for (auto e : edges){            int u = e[0], v = e[1];            if (uf.isConnected(u, v)){                return e;            }            uf.connect(u, v);        }        return vector<int>{-1, -1};    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;给定一个字符串 s，统计并返回具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是成组连续的。重复出现（不同位置）的子串也要统计它们出现的次数。&lt;/p&gt;
&lt;p&gt;输入：s &amp;#x3D; </summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="String" scheme="http://haolei56.github.io/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>130. 被围绕的区域</title>
    <link href="http://haolei56.github.io/2023/05211916.html"/>
    <id>http://haolei56.github.io/2023/05211916.html</id>
    <published>2023-05-21T09:16:44.091Z</published>
    <updated>2023-05-21T14:00:44.881Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code> ，找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><p><img src="https://s2.loli.net/2023/05/21/NUJ9nhQxRZbuygT.jpg" alt="黑白棋"></p><pre class="line-numbers language-C++"><code class="language-C++">输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>分析：</strong>你可以把那些不需要被替换的 O 看成⼀个拥有⼀个共同父节点的 dummy ，这些 O 和 dummy 互相连通，⽽那些需要被替换的 O 与 dummy 不连通。Union-Find 底层⽤的是⼀维数组，构造函数需要传⼊这个数组的⼤⼩，⽽题⽬给的是⼀个⼆维棋盘。这个很简单，<strong>⼆维坐标 (x,y) 可以转换成 x * n + y 这个数（ m 是棋盘的⾏数， n 是棋盘的列数）。这是将⼆维坐标映射到⼀维的常⽤技巧。</strong>索引 [0.. m*n-1] 都是棋盘内坐标的⼀维映射，那就让这个虚拟的 dummy 节点占据索引 m * n 好了。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">void solve(char board[][M]) {    if (board.length == 0) return;    int m = board.length;    int n = board[0].length;    UF uf(m * n + 1);// 给 dummy 留⼀个额外位置    int dummy = m * n;    for (int i = 0; i < m; i++) {// 将⾸列和末列的 O 与 dummy 连通        if (board[i][0] == 'O'){            uf.union(i * n, dummy);        }        if (board[i][n - 1] == 'O'){            uf.union(i * n + n - 1, dummy);        }    }    for (int j = 0; j < n; j++) {// 将⾸⾏和末⾏的 O 与 dummy 连通        if (board[0][j] == 'O'){            uf.union(j, dummy);        }        if (board[m - 1][j] == 'O'){            uf.union(n * (m - 1) + j, dummy);         }    }    int d[][2] = {{1,0}, {0,1}, {0,-1}, {-1,0}};// ⽅向数组 d 是上下左右搜索的常⽤⼿法    for (int i = 1; i < m - 1; i++){        for (int j = 1; j < n - 1; j++){            if (board[i][j] == 'O'){                for (int k = 0; k < 4; k++) {// 将此 O 与上下左右的 O 连通                    int x = i + d[k][0];                    int y = j + d[k][1];                    if (board[x][y] == 'O'){                        uf.union(x * n + y, i * n + j);                    }                }            }        }    }           for (int i = 1; i < m - 1; i++){// 所有不和 dummy 连通的 O，都要被替换        for (int j = 1; j < n - 1; j++){            if (!uf.connected(dummy, i * n + j)){                board[i][j] = 'X';            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：二维数组必须写明列数，行数可以不写明！</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;给你一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵 &lt;code&gt;board&lt;/code&gt; ，由若干字符 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt; ，找到所有被 &lt;cod</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Union-Find" scheme="http://haolei56.github.io/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>hash table</title>
    <link href="http://haolei56.github.io/2023/052121357.html"/>
    <id>http://haolei56.github.io/2023/052121357.html</id>
    <published>2023-05-21T09:15:25.947Z</published>
    <updated>2023-05-21T14:00:44.972Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-C++"><code class="language-C++">template <typename T>class HashTable{private:    vector<list<T>> hash_table;    // 哈希函数    int myhash(const T &obj) const{        return hash(obj, hash_table.size());    }public:    // size最好是质数    HashTable(int size = 31){        hash_table.reserve(size);        hash_table.resize(size);    }    ~HashTable() {}        // 查找哈希表是否存在该值    bool contains(const T &obj){        int hash_value = myhash(obj);        const list<T> &slot = hash_table[hash_value];        std::list<T>::const_iterator it = slot.cbegin();        for (; it != slot.cend() && *it != obj; ++it);        return it != slot.cend();    }        // 插入值    bool insert(const T &obj){        if (contains(obj)){            return false;        }        int hash_value = myhash(obj);        std::list<T> &slot = hash_table[hash_value];        slot.push_front(obj);        return true;    }        // 删除值    bool remove(const T &obj){        list<T> &slot = hash_table[myhash(obj)];        auto it = find(slot.begin(), slot.end(), obj);        if (it == slot.end()){            return false;        }        slot.erase(it);        return true;    }};// 一个简单的对整数实现的哈希函数int hash(const int &key, const int &tableSize){    return key % tableSize;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-C++&quot;&gt;&lt;code class=&quot;language-C++&quot;&gt;template &lt;typename T&gt;
class HashTable{
private:
    vector&lt;list&lt;T&gt;&gt; hash_t</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Graph" scheme="http://haolei56.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>128. 最长连续序列</title>
    <link href="http://haolei56.github.io/2023/052133458.html"/>
    <id>http://haolei56.github.io/2023/052133458.html</id>
    <published>2023-05-21T09:15:25.937Z</published>
    <updated>2023-05-21T14:00:44.878Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong> 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><pre><code>输入：nums = [100,4,200,1,3,2]输出：4解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></pre><p><strong>分析：</strong> 我们可以把所有数字放到一个哈希表，然后不断地从哈希表中任意取一个值，并删除掉其之前之后的所有连续数字，然后更新目前的最长连续序列长度。重复这一过程，我们就可以找到所有的连续数字序列。</p><p><strong>解答：</strong> </p><pre class="line-numbers language-C++"><code class="language-C++">int longestConsecutive(vector<int> &nums){    unordered_set<int> hash;    for (const int &num : nums){        hash.insert(num);    }    int ans = 0;    while (!hash.empty()){        int cur = *(hash.begin());        hash.erase(cur);        int next = cur + 1, prev = cur - 1;        while (hash.count(next)){            hash.erase(next++);        }        while (hash.count(prev)){            hash.erase(prev--);        }        ans = max(ans, next - prev - 1);    }    return ans;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：hash.count(x) 的数值只有 0 和 1。所以不能通过hash.count(x)来表示x在hash 中出现的次数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt; 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;/p&gt;
&lt;p&gt;请你设计并实现时间复杂度为 O(n) 的算法解决此问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入：nums = [100</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Graph" scheme="http://haolei56.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>深度优先</title>
    <link href="http://haolei56.github.io/2023/052122833.html"/>
    <id>http://haolei56.github.io/2023/052122833.html</id>
    <published>2023-05-21T09:13:52.763Z</published>
    <updated>2023-05-21T14:00:44.997Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-C++"><code class="language-C++">// 深度优先遍历函数void dfs(GraphNode* node, unordered_set<int>& visited) {    // 如果节点已经被访问过，则直接返回    if (visited.count(node->val)) {        return;    }    // 将当前节点标记为已访问    visited.insert(node->val);    cout << node->val << " "; // 打印节点值    // 递归遍历所有相邻节点    for (auto neighbor : node->neighbors) {        dfs(neighbor, visited);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-C++&quot;&gt;&lt;code class=&quot;language-C++&quot;&gt;// 深度优先遍历函数
void dfs(GraphNode* node, unordered_set&lt;int&gt;&amp; visited) {
    /</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Graph" scheme="http://haolei56.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>广度优先</title>
    <link href="http://haolei56.github.io/2023/052116480.html"/>
    <id>http://haolei56.github.io/2023/052116480.html</id>
    <published>2023-05-21T09:13:52.757Z</published>
    <updated>2023-05-21T14:00:44.992Z</updated>
    
    <content type="html"><![CDATA[<p>BFS 算法本质就是让你在一幅图中找到从起点<code>start</code>到终点<code>target</code>的最近距离。BFS 算法都是用队列这种数据结构，每次将一个节点周围的所有节点加入队列。可以看成是树的层次遍历的一种延伸。</p><p>BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。</p><pre class="line-numbers language-C++"><code class="language-C++">// 计算从起点 start 到终点 target 的最近距离int BFS(Node* start, Node* target) {    Queue<Node*> q; // 核心数据结构    Set<Node*> visited; // 避免走回头路    q.push(start); // 将起点加入队列    visited.insert(start);    int step = 0; // 记录扩散的步数    while (!q.empty()) {        int sz = q.size();        /* 将当前队列中的所有节点向四周扩散 */        for (int i = 0; i < sz; i++) {            Node* cur = q.front();            q.pop();            /* 划重点：这里判断是否到达终点 */            if (cur==target)                return step;            /* 将 cur 的相邻节点加入队列 */            for (Node* x : cur.adj())                if (!visited.count(x)) {                    q.push(x);                    visited.insert(x);                }        }        /* 划重点：更新步数在这里 */        step++;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注;cur.adj()泛指cur相邻的节点，比如说二维数组中，cur上下左右四面的位置就是相邻节点；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;BFS 算法本质就是让你在一幅图中找到从起点&lt;code&gt;start&lt;/code&gt;到终点&lt;code&gt;target&lt;/code&gt;的最近距离。BFS 算法都是用队列这种数据结构，每次将一个节点周围的所有节点加入队列。可以看成是树的层次遍历的一种延伸。&lt;/p&gt;
&lt;p&gt;BFS 可以找</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Graph" scheme="http://haolei56.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>752. 打开转盘锁</title>
    <link href="http://haolei56.github.io/2023/052134905.html"/>
    <id>http://haolei56.github.io/2023/052134905.html</id>
    <published>2023-05-21T09:13:52.744Z</published>
    <updated>2023-05-21T14:00:44.949Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><pre class="line-numbers language-C++"><code class="language-C++">输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"输出：6解释：可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，因为当拨动到 "0102" 时这个锁就会被锁定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析：</strong>如果你只转一下锁，有几种可能？总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能对吧。比如说从<code>&quot;0000&quot;</code>开始，转一次，可以穷举出<code>&quot;1000&quot;, &quot;9000&quot;, &quot;0100&quot;, &quot;0900&quot;...</code>共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…</p><p>仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点，又是求最短距离，这就是典型的 BFS </p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++"> // 将 s[j] 向上拨动一次string plusOne(string s, int j) {    if (s[j] == '9')        s[j] = '0';    else        s[j] += 1;    return s;}// 将 s[i] 向下拨动一次string minusOne(string s, int j) {    if (s[j] == '0')        s[j] = '9';    else        s[j] -= 1;    return s;}int openLock(vector<string>& deadends, string target) {    // 记录需要跳过的死亡密码    set<string> deads ;    for (string s : deadends) deads.insert(s);    // 记录已经穷举过的密码，防止走回头路    set<string> visited ;    queue<string> q ;    // 从起点开始启动广度优先搜索    int step = 0;    q.push("0000");    visited.insert("0000");    while (!q.empty()) {        int sz = q.size();        /* 将当前队列中的所有节点向周围扩散 */        for (int i = 0; i < sz; i++) {            string cur = q.front();            /* 判断是否到达终点 */            if (deads.count(cur))                continue;            if (strcmp(cur.c_str(),target.c_str())==0)//c_str()就是将C++的string转化为C的字符串数组！！！C中没有string，所以函数c_str()就是将C++的string转化为C的字符串数组                return step;            /* 将一个节点的未遍历相邻节点加入队列 */            for (int j = 0; j < 4; j++) {                string up = plusOne(cur, j);                if (!visited.count(up)) {                    q.push(up);                    visited.insert(up);                }                string down = minusOne(cur, j);                if (!visited.count(down)) {                    q.push(down);                    visited.insert(down);                }            }        }        /* 在这里增加步数 */        step++;    }    // 如果穷举完都没找到目标密码，那就是找不到了    return -1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为 ‘0’，’0’ 变为 ‘9’ </summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Graph" scheme="http://haolei56.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>210. 课程表2</title>
    <link href="http://haolei56.github.io/2023/052141222.html"/>
    <id>http://haolei56.github.io/2023/052141222.html</id>
    <published>2023-05-21T09:13:13.856Z</published>
    <updated>2023-05-21T14:00:44.897Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] &#x3D; [ai, bi] ，表示在选修课程 ai 前 必须 先选修 bi 。</p><p>例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。<br>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组 。</p><p><strong>分析：</strong>拓扑排序（topological sort）是一种常见的，对有向无环图排序的算法。给定有向无环图中的N 个节点，我们把它们排序成一个线性序列；若原图中节点i 指向节点j，则排序结果中i 一定在j 之前。拓扑排序的结果不是唯一的，只要满足以上条件即可。</p><p>我们可以先建立一个邻接矩阵表示图，方便进行直接查找。这里注意我们将所有的边反向，使得如果课程i 指向课程j，那么课程i 需要在课程j 前面先修完。这样更符合我们的直观理解。拓扑排序也可以被看成是广度优先搜索的一种情况：我们先遍历一遍所有节点，把入度为0的节点（即没有前置课程要求）放在队列中。在每次从队列中获得节点时，我们将该节点放在目前排序的末尾，并且把它指向的课程的入度各减1；如果在这个过程中有课程的所有前置必修课都已修完（即入度为0），我们把这个节点加入队列中。当队列的节点都被处理完时，说明所有的节点都已排好序，或因图中存在循环而无法上完所有课程。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">vector<int> findOrder(int numCourses, vector<vector<int>> &prerequisites){    vector<vector<int>> graph(numCourses, vector<int>());    vector<int> indegree(numCourses, 0), res;    for (const auto &prerequisite : prerequisites){        graph[prerequisite[1]].push_back(prerequisite[0]);        ++indegree[prerequisite[0]];    }    queue<int> q;    for (int i = 0; i < indegree.size(); ++i){        if (!indegree[i]){            q.push(i);        }    }    while (!q.empty()){        int u = q.front();        res.push_back(u);        q.pop();        for (auto v : graph[u]){            --indegree[v];            if (!indegree[v]){                q.push(v);            }        }    }    for (int i = 0; i < indegree.size(); ++i){        if (indegree[i]){            return vector<int>();        }    }    return res;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] &amp;#x3D; [ai, bi] ，表示在选修课程 ai 前</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Graph" scheme="http://haolei56.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>785. 判断二分图</title>
    <link href="http://haolei56.github.io/2023/052126083.html"/>
    <id>http://haolei56.github.io/2023/052126083.html</id>
    <published>2023-05-21T09:12:16.429Z</published>
    <updated>2023-05-21T14:00:44.955Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：<br>不存在自环（graph[u] 不包含 u）。<br>不存在平行边（graph[u] 不包含重复值）。<br>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）<br>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。<br>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。如果图是二分图，返回 true ；否则，返回 false 。</p><p><strong>分析：</strong>二分图算法也称为染色法，是一种广度优先搜索。如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么图为二分。利用队列和广度优先搜索，我们可以对未染色的节点进行染色，并且检查是否有颜色相同的相邻节点存在。注意在代码中，我们用0 表示未检查的节点，用1 和2 表示两种不同的颜色。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">bool isBipartite(vector<vector<int>> &graph){    int n = graph.size();    if (n == 0){        return true;    }    vector<int> color(n, 0);    queue<int> q;    for (int i = 0; i < n; ++i){        if (!color[i]){            q.push(i);            color[i] = 1;        }        while (!q.empty()){            int node = q.front();            q.pop();            for (const int &j : graph[node]){                if (color[j] == 0){                    q.push(j);                    color[j] = color[node] == 2 ? 1 : 2;                }                else if (color[node] == color[j]){                    return false;                }            }        }    }    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] </summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Graph" scheme="http://haolei56.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>字典树</title>
    <link href="http://haolei56.github.io/2023/052144156.html"/>
    <id>http://haolei56.github.io/2023/052144156.html</id>
    <published>2023-05-21T09:11:41.270Z</published>
    <updated>2023-05-21T14:00:44.987Z</updated>
    
    <content type="html"><![CDATA[<p>字典树（Trie）用于判断字符串是否存在或者是否具有某种字符串前缀。</p><p>为什么需要用字典树解决这类问题呢？假如我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度n 通常在10 以内，如果我们使用字典树，则可以在O(n)——近似O(1)的时间内完成搜索，且额外开销非常小。<img src="https://s2.loli.net/2023/05/21/IZXcijhsvYbtxWw.jpg" alt="字典树.jpg"></p><pre class="line-numbers language-C++"><code class="language-C++">class TrieNode{public:    TrieNode *childNode[26];    bool isVal;    TrieNode() : isVal(false){        for (int i = 0; i < 26; ++i){            childNode[i] = nullptr;        }    }};class Trie{    TrieNode *root;public:    Trie() : root(new TrieNode()) {}    // 向字典树插入一个词    void insert(string word){        TrieNode *temp = root;        for (int i = 0; i < word.size(); ++i){            if (!temp->childNode[word[i] -’a’]){                temp->childNode[word[i] -’a’] = new TrieNode();            }            temp = temp->childNode[word[i] -’a’];        }        temp->isVal = true;    }    // 判断字典树里是否有一个词    bool search(string word){        TrieNode *temp = root;        for (int i = 0; i < word.size(); ++i){            if (!temp){                break;            }            temp = temp->childNode[word[i] -’a’];        }        return temp ? temp->isVal : false;    }    // 判断字典树是否有一个以词开始的前缀    bool startsWith(string prefix){        TrieNode *temp = root;        for (int i = 0; i < prefix.size(); ++i){            if (!temp){                break;            }            temp = temp->childNode[prefix[i] -’a’];        }        return temp;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字典树（Trie）用于判断字符串是否存在或者是否具有某种字符串前缀。&lt;/p&gt;
&lt;p&gt;为什么需要用字典树解决这类问题呢？假如我们有一个储存了近万个单词的字典，即使我们使用哈希，在其中搜索一个单词的实际开销也是非常大的，且无法轻易支持搜索单词前缀。然而由于一个英文单词的长度n </summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>1110. 删点成林</title>
    <link href="http://haolei56.github.io/2023/052150937.html"/>
    <id>http://haolei56.github.io/2023/052150937.html</id>
    <published>2023-05-21T09:07:37.515Z</published>
    <updated>2023-05-21T14:00:44.877Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>给出二叉树的根节点 root，树上每个节点都有一个不同的值。如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。</p><pre><code>输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]输出：[[1,2,null,4],[6],[7]]</code></pre><p><strong>分析：</strong>这道题最主要需要注意的细节是如果通过递归处理原树，以及需要在什么时候断开指针。同时，为了便于寻找待删除节点，可以建立一个哈希表方便查找。笔者强烈建议读者在看完题解后，自己写一遍本题，加深对于递归的理解和运用能力。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">// 主函数vector<TreeNode *> delNodes(TreeNode *root, vector<int> &to_delete){    vector<TreeNode *> forest;    unordered_set<int> dict(to_delete.begin(), to_delete.end());    root = helper(root, dict, forest);    if (root){        forest.push_back(root);    }    return forest;}// 辅函数TreeNode *helper(TreeNode *root, unordered_set<int> &dict, vector<TreeNode *> &forest){    if (!root){        return root;    }    root->left = helper(root->left, dict, forest);    root->right = helper(root->right, dict, forest);    if (dict.count(root->val)){        if (root->left){            forest.push_back(root->left);        }        if (root->right){            forest.push_back(root->right);        }        root = NULL;    }    return root;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;给出二叉树的根节点 root，树上每个节点都有一个不同的值。如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>543. 二叉树的直径</title>
    <link href="http://haolei56.github.io/2023/052138653.html"/>
    <id>http://haolei56.github.io/2023/052138653.html</id>
    <published>2023-05-21T09:07:37.510Z</published>
    <updated>2023-05-21T14:00:44.931Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p><p><strong>分析：</strong>同样的，我们可以利用递归来处理树。解题时要注意，在我们处理某个子树时，我们更新的最长直径值和递归返回的值是不同的。这是因为待更新的最长直径值是经过该子树根节点的最长直径（即两侧长度）；而函数返回值是以该子树根节点为端点的最长直径值（即一侧长度），使用这样的返回值才可以通过递归更新父节点的最长直径值）。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">class Solution {public:    int maxDepth(TreeNode* root, int &diameter)    {        if(!root)        {            return 0;//如果根节点不存在，则最大深度就是0        }        int left = maxDepth(root->left, diameter), right = maxDepth(root->right, diameter);        diameter = max(left+right, diameter);//求左右子树的最大深度之和，用于更新当前的直径        return 1 + max(left, right);//返回当前结点的深度    }    int diameterOfBinaryTree(TreeNode* root) {        int diameter = 0;        if(root)        {            maxDepth(root, diameter);        }        return diameter;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;同样的，我们可以利用递归来处理树。解题时要注意，</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>110. 平衡二叉树</title>
    <link href="http://haolei56.github.io/2023/052153625.html"/>
    <id>http://haolei56.github.io/2023/052153625.html</id>
    <published>2023-05-21T09:07:37.506Z</published>
    <updated>2023-05-21T14:00:44.875Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-C++"><code class="language-C++">class Solution {public:    bool isBalanced(TreeNode* root) {        if(root==nullptr) return true;            return abs(depth(root->left)-depth(root->right))<=1&&isBalanced(root->left)&&isBalanced(root->right);    }        int depth(TreeNode* pRoot){        if(pRoot==nullptr) return 0;        return max(depth(pRoot->left),depth(pRoot->right))+1;    }};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-C++&quot;&gt;&lt;code class=&quot;language-C++&quot;&gt;class Solution {
public:
    bool isBalanced(TreeNode* root) {
        if(</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>105. 从前序与中序遍历序列构造二叉树</title>
    <link href="http://haolei56.github.io/2023/052162403.html"/>
    <id>http://haolei56.github.io/2023/052162403.html</id>
    <published>2023-05-21T09:07:37.501Z</published>
    <updated>2023-05-21T14:00:44.874Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><pre class="line-numbers language-C++"><code class="language-C++">Input: preorder = [4,9,20,15,7], inorder = [9,4,15,20,7]Output:4/ \9 20/ \15 7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析：</strong>我们通过本题的样例讲解一下本题的思路。前序遍历的第一个节点是4，意味着4 是根节点。我们在中序遍历结果里找到4 这个节点，根据中序遍历的性质可以得出，4 在中序遍历数组位置的左子数组为左子树，节点数为1，对应的是前序排列数组里4 之后的1 个数字（9）；4 在中序遍历数组位置的右子数组为右子树，节点数为3，对应的是前序排列数组里最后的3 个数字。有了这些信息，我们就可以对左子树和右子树进行递归复原了。为了方便查找数字的位置，我们可以用哈希表预处理中序遍历的结果。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">// 主函数TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder){    if (preorder.empty()){        return nullptr;    }    unordered_map<int, int> hash;    for (int i = 0; i < preorder.size(); ++i){        hash[inorder[i]] = i;    }    return buildTreeHelper(hash, preorder, 0, preorder.size() - 1, 0);}// 辅函数TreeNode *buildTreeHelper(unordered_map<int, int> &hash, vector<int> &preorder, int s0, int e0, int s1){    if (s0 > e0){        return nullptr;    }    int mid = preorder[s1], index = hash[mid], leftLen = index - s0 - 1;    TreeNode *node = new TreeNode(mid);    node->left = buildTreeHelper(hash, preorder, s0, index - 1, s1 + 1);    node->right = buildTreeHelper(hash, preorder, index + 1, e0, s1 + 2 + leftLen);    return node;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。&lt;/p&gt;
&lt;pre class=&quot;line-numbers la</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>104. 二叉树的最大深度</title>
    <link href="http://haolei56.github.io/2023/052155994.html"/>
    <id>http://haolei56.github.io/2023/052155994.html</id>
    <published>2023-05-21T09:07:37.490Z</published>
    <updated>2023-05-21T14:00:44.873Z</updated>
    
    <content type="html"><![CDATA[<pre class="line-numbers language-C++"><code class="language-C++">int maxDepth(TreeNode* root) {    return root? 1 + max(maxDepth(root->left), maxDepth(root->right)): 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;pre class=&quot;line-numbers language-C++&quot;&gt;&lt;code class=&quot;language-C++&quot;&gt;int maxDepth(TreeNode* root) {
    return root? 1 + max(maxDepth(root-&gt;lef</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>101. 对称二叉树</title>
    <link href="http://haolei56.github.io/2023/052149472.html"/>
    <id>http://haolei56.github.io/2023/052149472.html</id>
    <published>2023-05-21T09:07:37.486Z</published>
    <updated>2023-05-21T14:00:44.871Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目：</strong>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>分析：</strong>判断一个树是否对称等价于判断左右子树是否对称。笔者一般习惯将判断两个子树是否相等或对称类型的题的解法叫做“四步法”：（1）如果两个子树都为空指针，则它们相等或对称（2）如果两个子树只有一个为空指针，则它们不相等或不对称（3）如果两个子树根节点的值不相等，则它们不相等或不对称（4）根据相等或对称要求，进行递归处理。</p><p><strong>解答：</strong></p><pre class="line-numbers language-C++"><code class="language-C++">// 主函数bool isSymmetric(TreeNode *root){    return root ? isSymmetric(root->left, root->right) : true;}// 辅函数bool isSymmetric(TreeNode *left, TreeNode *right){    if (!left && !right){        return true;    }    if (!left || !right){        return false;    }    if (left->val != right->val){        return false;    }    return isSymmetric(left->left, right->right) && isSymmetric(left->right,right->left);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;给你一个二叉树的根节点 &lt;code&gt;root&lt;/code&gt; ， 检查它是否轴对称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;判断一个树是否对称等价于判断左右子树是否对称。笔者一般习惯将判断两个子树是否相等或对称类型的题的</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>树的中序遍历</title>
    <link href="http://haolei56.github.io/2023/052163137.html"/>
    <id>http://haolei56.github.io/2023/052163137.html</id>
    <published>2023-05-21T09:04:38.557Z</published>
    <updated>2023-05-21T14:00:44.974Z</updated>
    
    <content type="html"><![CDATA[<p>递归：</p><pre class="line-numbers language-C++"><code class="language-C++">void inorder(TreeNode* root) {    inorder(root->left);    visit(root);    inorder(root->right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归：</p><pre class="line-numbers language-C++"><code class="language-C++">vector<int> inorderTraversal(TreeNode* root) {    vector<int> result;    stack<TreeNode*> s;    TreeNode* current = root;    while (current != NULL || !s.empty()) {        while (current != NULL) {            s.push(current);            current = current->left;        }        current = s.top();        s.pop();        result.push_back(current->val);        current = current->right;    }    return result;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;递归：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-C++&quot;&gt;&lt;code class=&quot;language-C++&quot;&gt;void inorder(TreeNode* root) {
    inorder(root-&gt;left);
    vis</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>树的前序遍历</title>
    <link href="http://haolei56.github.io/2023/052141894.html"/>
    <id>http://haolei56.github.io/2023/052141894.html</id>
    <published>2023-05-21T09:04:38.553Z</published>
    <updated>2023-05-21T14:00:44.981Z</updated>
    
    <content type="html"><![CDATA[<p>递归：</p><pre class="line-numbers language-C++"><code class="language-C++">void preorder(TreeNode* root) {    visit(root);    preorder(root->left);    preorder(root->right);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>非递归：</p><pre class="line-numbers language-C++"><code class="language-C++">vector<int> preorderTraversal(TreeNode *root){    vector<int> ret;    if (!root){        return ret;    }    stack<TreeNode *> s;    s.push(root);    while (!s.empty()){        TreeNode *node = s.top();        s.pop();        ret.push_back(node->val);        if (node->right){            s.push(node->right); // 先右后左，保证左子树先遍历        }        if (node->left){            s.push(node->left);        }    }    return ret;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;递归：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-C++&quot;&gt;&lt;code class=&quot;language-C++&quot;&gt;void preorder(TreeNode* root) {
    visit(root);
    preorder(r</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://haolei56.github.io/categories/Algorithm/"/>
    
    
    <category term="Tree" scheme="http://haolei56.github.io/tags/Tree/"/>
    
  </entry>
  
</feed>
