<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝暮惜</title>
  
  <subtitle>浮生三千</subtitle>
  <link href="http://haolei56.github.io/atom.xml" rel="self"/>
  
  <link href="http://haolei56.github.io/"/>
  <updated>2022-12-19T14:16:22.175Z</updated>
  <id>http://haolei56.github.io/</id>
  
  <author>
    <name>HL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库</title>
    <link href="http://haolei56.github.io/2022/12194.html"/>
    <id>http://haolei56.github.io/2022/12194.html</id>
    <published>2022-12-19T13:28:21.356Z</published>
    <updated>2022-12-19T14:16:22.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用前的相关操作"><a href="#使用前的相关操作" class="headerlink" title="使用前的相关操作"></a>使用前的相关操作</h3><ul><li><p>连接mysql：mysql -h 主机名 -p 端口 -u 用户名 -p密码   </p><p>注意密码前没有空格，-h主机名和-p端口可以省略，省略是默认为本机和3306</p></li><li><p>查看所有数据库：show databases;</p></li><li><p>使用某个数据库：use 数据库名;</p></li><li><p>创建或销毁数据库：create&#x2F;drop database 数据库名;  </p><p>创建数据库时名称中加反引号(&#96;&#96;)是为了规避关键字，character set为字符集，默认为utf8，couate为校对规则，默认为utf8-general-ci，即不区分大小写。</p></li><li><p>备份数据库：mysqldump -u 用户名 -p密码 -B 数据库名 &gt;文件名.sql(路径);</p></li><li><p>恢复数据库：source 文件名.sql;</p></li><li><p>备份表：mysqldump -u 用户名 -p密码 -B 数据库名 表名 &gt;文件名.sql</p></li><li><p>创建表：create table 表名（字段名 字段类型，……）;</p></li><li><p>修改表：</p><ol><li>添加列：alter table 表名 add (字段名 字段类型，……);</li><li>修改列：alter table 表名 modify (字段名 字段类型，……);</li><li>删除列：alter table 表名 drop (列名);</li><li>修改列名：alter table 表名 change 列名 新列名 类型;</li></ol></li><li><p>表复制：insert into 表1 select * from 表1;</p></li><li><p>表去重：</p><ol><li>先创建一张临时表表2，该表的结构和表1一样：create table 表2 like 表1;</li><li>把表1的记录通过distinct关键字复制到表2：insert into 表2 select distinct * from 表1;</li></ol></li><li><p>查看所有列：desc 表名;</p></li><li><p>修改表名：rename table 表名 to 新表名;</p></li></ul><h3 id="CRUD-create-read-update-delete"><a href="#CRUD-create-read-update-delete" class="headerlink" title="CRUD(create,read,update,delete)"></a>CRUD(create,read,update,delete)</h3><ul><li><p>插入：insert into 表名 (字段名,…..) values (对应数据);</p></li><li><p>修改：update 表名 set 字段名&#x3D;  where …;</p></li><li><p>删除：delete from 表名 where ….;</p><p>修改和删除语句不带where子句会影响数据库中所有记录。</p></li><li><p><strong>查询</strong>：select * from 表名 where …;</p><ul><li><p>过滤重复数据：在select后加上distinct</p></li><li><p>别名：select 字段名 as 别名 from 表名;</p></li><li><p>where子句中经常使用的运算符：&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&#x3D;,&lt;&gt;,!&#x3D;,between…and…,in,like,not like,is null,and,or,not</p><p><u>like操作符：%表示0到多个任意字符，_表示一个任意字符</u></p><p><u>concat()函数：用于将两个字符串连接起来，形成一个单一的字符串。</u></p><p><u>判断某列值是否为空应该使用is而不是&#x3D;。</u></p><p><u>日期类型可以直接比较，需要注意格式。</u></p></li><li><p>分组：group by 列名 having …;  &#x2F;&#x2F;使用having子句对分组后的结果进行过滤。</p></li><li><p>排序：order by 列名(或者别名) asc(或desc)  &#x2F;&#x2F;默认为升序;</p></li><li><p>分页：select … limit start,rows;  &#x2F;&#x2F;从start+1行开始取，取rows行，start可以从0开始</p><p>以上三个子句顺序：分组、排序、分页</p></li><li><p>统计函数：</p><table><thead><tr><th align="center">语法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">select count(*或者列名) from 表名 where …;</td><td align="center">count(*)是返回满足条件的记录行数，而count(列名)是统计满足条件的记录行数，会排除null的情况。</td></tr><tr><td align="center">select sum(列名) ,sum(列名)… from 表名 where …;</td><td align="center">返回满足条件的行的数值和，一般使用在数值列，sum仅对数值起作用</td></tr><tr><td align="center">select avg(列名) ,avg(列名)… from 表名 where …;</td><td align="center">返回满足条件的列的平均值</td></tr><tr><td align="center">max&#x2F;min</td><td align="center">返回满足条件的列的最值</td></tr></tbody></table></li><li><p>多表查询：</p><ol><li>笛卡尔集：在默认情况下，当两个表查询时，从第一张表中取出一行和第二张表的每一行进行组合，一共返回的记录数是两表的行数的乘积，这种多表查询默认返回结果称为笛卡尔积。</li><li>解决笛卡尔集的关键要写出正确的过滤条件where，且多表查询的条件不能少于表数减一。</li><li>自连接：把一张表当做两张表使用，需要给表起别名（不用as，而是表名 别名）</li></ol></li><li><p>子查询：又叫嵌套查询。是指嵌入在其它sql语句中的select语句。</p><ol><li>单行子查询：只返回一行数据的子查询语句。</li><li>多行子查询：返回多行数据的子查询语句，使用关键字in。</li><li>多行子查询：返回多行数据的子查询。…where (字段1，字段2….) &#x3D; (select 字段1,字段2…)</li></ol></li><li><p>合并查询：合并多个select语句的结果。union(去重)，union all(不去重)</p></li><li><p>外连接：</p><ol><li>左外连接：即使左表与右表有不匹配的信息，也会把左表的信息显示出来。select … from 左表 left join 右表 on 条件</li><li>右外连接：类比左外连接。</li></ol></li></ul></li></ul><h3 id="应用相关"><a href="#应用相关" class="headerlink" title="应用相关"></a>应用相关</h3><ul><li><p>主键：不能重复且不为空，但可以为复合主键（即把几个字段合起来作为一个主键）。</p></li><li><p>外键：</p><ol><li>外键指向的表的字段，要求是主键或者是unique</li><li>外键字段的值，必须在另一个表中对应主键中出现过或者为空（前提是外键字段允许为空）</li><li>一旦建立了外键约束关系，数据就不能随意删除了，没有任何一条记录指向主表中的记录时则可以删除主表中的该记录。</li><li>外键在其他表中为普通字段。</li></ol></li><li><p>索引：主键自动为索引、唯一（unique）索引、普通索引、全文索引</p><p>​    创建索引：create index 索引号 on 表名 （列名）;或者alter table 表名 add index  索引名（列名）;</p><p>​     删除索引：drop index 索引名 on 表名;</p><p>​     查询索引：show index from 表名;</p><ol><li>能够提高数据库的性能，查询速度能到极大提升，但会占用磁盘空间（以空间换时间）</li><li>没有索引时，查询时会对全表进行扫描，比较慢，使用索引后，会形成一个索引的数据结构（比如二叉树），极大提高查询速度</li><li>如果对表进行修改、删除、添加操作，会对索引进行维护（结构重构），对速度有影响，但一般查询操作比较多，利大于弊。</li><li>比较频繁的作为查询条件的字段合适使用索引，唯一性太差、更新操作频繁，不会出现在where子句中的字段不适合创建索引。</li></ol></li><li><p>事务：用于保证数据的一致性，它是由一组相关的dml（增删改）语句组成，该组dml语句要么全部成功，要么全部失败。</p><p>相关操作：set autocommit&#x3D;off  start transaction   savepoint  rollback to  rollback  commit</p><ol><li>当执行事务操作时，mysql会在表上加锁，防止其他用户修改表的数据。</li><li>保存点是事务中的点，用于取消部分事务，当事务结束时（commit），会自动删除该事务所定义的所有保存点。</li><li>当执行commit语句后，会确认事务变化，结束事务，释放锁，数据生效。</li><li>事务的ACID特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）</li></ol></li><li><p>隔离级别：当多个连接开启事务操作数据库中的数据时，为保证数据的准确性，数据库系统要负责隔离操作。</p><ol><li><p>如果不考虑隔离性，可能引发脏读、不可重复读、幻读。</p><ul><li>脏读：当一个事务读取另一个事务尚未提交的改变时，会产生脏读。</li><li>不可重复读：同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集。</li><li>幻读：同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集。</li></ul></li><li><p>隔离级别跟事务相关。隔离的四种级别：</p><table><thead><tr><th align="center">级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">加锁</th></tr></thead><tbody><tr><td align="center">读未提交</td><td align="center">会</td><td align="center">会</td><td align="center">会</td><td align="center">不加</td></tr><tr><td align="center">读已提交</td><td align="center">不会</td><td align="center">会</td><td align="center">会</td><td align="center">不加</td></tr><tr><td align="center">可重复读（默认）</td><td align="center">不会</td><td align="center">不会</td><td align="center">不会</td><td align="center">不加</td></tr><tr><td align="center">可串行化</td><td align="center">不会</td><td align="center">不会</td><td align="center">不会</td><td align="center">加</td></tr></tbody></table></li></ol></li></ul><p>​             </p><ul><li>视图：是一个虚拟表，其内容由查询定义，同真实表一样，视图包含列，其数据来自对应的真实表（基表）。<ol><li>通过视图可以修改基表的数据，基表的改变也会影响视图的显示。</li><li>创建视图后，到数据库去看，只有一个视图结构文件，没有数据文件。</li><li>视图可以再使用视图，数据仍然来自基表。</li><li>一些数据表有些信息是保密的，不让用户直接看到，这时就可以创建一个视图。</li></ol></li></ul><p>​                                 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用前的相关操作&quot;&gt;&lt;a href=&quot;#使用前的相关操作&quot; class=&quot;headerlink&quot; title=&quot;使用前的相关操作&quot;&gt;&lt;/a&gt;使用前的相关操作&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;连接mysql：mysql -h 主机名 -p 端口 -u 用户名 -p密</summary>
      
    
    
    
    <category term="Datebase" scheme="http://haolei56.github.io/categories/Datebase/"/>
    
    
    <category term="datebase" scheme="http://haolei56.github.io/tags/datebase/"/>
    
  </entry>
  
  <entry>
    <title>spring注解</title>
    <link href="http://haolei56.github.io/2022/12193.html"/>
    <id>http://haolei56.github.io/2022/12193.html</id>
    <published>2022-12-19T13:28:21.352Z</published>
    <updated>2022-12-19T14:15:47.392Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="spring注解"><a href="#spring注解" class="headerlink" title="spring注解"></a>spring注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>这个注解是 Spring Boot 项目的基石，创建 SpringBoot 项目之后会默认在主类加上。一般不会主动去使用它。可以把 @SpringBootApplication看作是 @Configuration、@ComponentScan 、@EnableAutoConfiguration注解的集合。三个注解的作用分别是：</p><ul><li>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</li><li>@ComponentScan： 扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li><li>@Configuration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li></ul><h3 id="spring-bean-相关："><a href="#spring-bean-相关：" class="headerlink" title="spring bean 相关："></a>spring bean 相关：</h3><ol><li><p><strong>@Autowired：</strong>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理。一般使用 @Autowired 注解让 Spring 容器自动装配 bean。要想把类标识成可用于 @Autowired注解自动装配的 bean 的类,可以采用以下注解实现：</p><ul><li><p><strong>@Component</strong> ：通用的注解，可标注任意类为 Spring组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</p></li><li><p>**@Repository **: 对应持久层即 Dao 层，主要用于数据库相关操作。</p></li><li><p><strong>@Service</strong> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p></li><li><p><strong>@Controller</strong>: 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</p><pre><code class="java">@Component(&quot;c&quot;)public class Category &#123;    ....&#125;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)public class TestSpring &#123;    @Autowired    Category c;    @Test    public void test()&#123;        System.out.println(c.getName());    &#125;&#125;</code></pre></li></ul></li><li><p>**@RestController:**是@Controller和@ResponseBody的合集,表示这是个控制器 bean,并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。现在的前后端分离，基本不用@Controller。单独使用 @Controller不加 @ResponseBody的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。@Controller +@ResponseBody 返回 JSON 或 XML 形式数据。</p></li><li><p><strong>@Scope：</strong>声明 Spring Bean 的作用域。四种常见的 Spring Bean 的作用域：</p><ul><li><p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</p></li><li><p>prototype : 每次请求都会创建一个新的 bean 实例。</p></li><li><p>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p></li><li><p>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</p><pre><code class="java">@Bean@Scope(&quot;singleton&quot;)public Person personSingleton() &#123;    return new Person();&#125;</code></pre></li></ul></li><li><p><strong>@Configuration：</strong>一般用来声明配置类，可以使用 @Component注解替代，不过使用@Configuration注解声明配置类更加语义化。</p></li></ol><h3 id="处理常见的http请求"><a href="#处理常见的http请求" class="headerlink" title="处理常见的http请求"></a>处理常见的http请求</h3><ol><li><p>5 种常见的请求类型:</p><ul><li>GET ：请求从服务器获取特定资源。举个例子：GET &#x2F;users（获取所有学生）</li><li>POST ：在服务器上创建一个新的资源。举个例子：POST &#x2F;users（创建学生）</li><li>PUT ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：PUT &#x2F;users&#x2F;12（更新编号为 12 的学生）</li><li>DELETE：从服务器删除特定的资源。举个例子：DELETE &#x2F;users&#x2F;12（删除编号为 12 的学生）</li><li>PATCH ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li></ul></li><li><p>**@GetMapping(“users”)**等价@RequestMapping(value&#x3D;”&#x2F;users”,method&#x3D;RequestMethod.GET)</p><pre><code class="java">@GetMapping(&quot;/users&quot;)public ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123; return userRepository.findAll();&#125;</code></pre></li><li><p>**@PostMapping(“users”) **等价@RequestMapping(value&#x3D;”&#x2F;users”,method&#x3D;RequestMethod.POST)</p><pre><code class="java">@PostMapping(&quot;/users&quot;)public ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody UserCreateRequest userCreateRequest) &#123; return userRespository.save(userCreateRequest);&#125;</code></pre></li><li><p>**@PutMapping(“&#x2F;users&#x2F;{userId}”)**等价@RequestMapping(value&#x3D;”&#x2F;users&#x2F;{userId}”,method&#x3D;RequestMethod.PUT)</p><pre><code class="java">@PutMapping(&quot;/users/&#123;userId&#125;&quot;)public ResponseEntity&lt;User&gt; updateUser(@PathVariable(value = &quot;userId&quot;) Long userId,  @Valid @RequestBody UserUpdateRequest userUpdateRequest) &#123;  ......&#125;</code></pre></li><li><p>**@DeleteMapping(“&#x2F;users&#x2F;{userId}”)**等价于@RequestMapping(value&#x3D;”&#x2F;users&#x2F;{userId}”,method&#x3D;RequestMethod.DELETE)</p><pre><code class="java">@DeleteMapping(&quot;/users/&#123;userId&#125;&quot;)public ResponseEntity deleteUser(@PathVariable(value = &quot;userId&quot;) Long userId)&#123;  ......&#125;</code></pre></li></ol><h3 id="前后端传值"><a href="#前后端传值" class="headerlink" title="前后端传值"></a>前后端传值</h3><ol><li><p><strong>@PathVariable</strong>用于获取路径参数，**@RequestParam**用于获取查询参数。</p><pre><code class="java">@GetMapping(&quot;/klasses/&#123;klassId&#125;/teachers&quot;)public List&lt;Teacher&gt; getKlassRelatedTeachers(         @PathVariable(&quot;klassId&quot;) Long klassId,         @RequestParam(value = &quot;type&quot;, required = false) String type ) &#123;...&#125;//如果我们请求的 url 是：/klasses/123456/teachers?type=web//那么我们服务获取到的数据就是：klassId=123456,type=web。</code></pre></li><li><p><strong>@RequestBody</strong>:用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且Content-Type 为 application&#x2F;json 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用HttpMessageConverter或者自定义的HttpMessageConverter将请求的 body 中的 json 字符串转换为 java 对象。</p></li><li><p>一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam和@PathVariable。 如果你的方法必须要用两个 @RequestBody来接受数据的话，大概率是你的数据库设计或者系统设计出问题了！</p></li></ol><h3 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="读取配置信息"></a>读取配置信息</h3><p>假设配置文件application.yml如下：</p><pre><code class="java">wuhan2020: 2020年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！my-profile:  name: 梦溪龙游  email: 123456789@163.comlibrary:  location: 湖北武汉加油中国加油  books:    - name: 天才基本法      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。    - name: 时间的秩序      description: 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。    - name: 了不起的我      description: 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？</code></pre><ol><li><p>使用 **@Value(“${property}”) **读取比较简单的配置信息：</p><pre><code class="java">@Value(&quot;$&#123;wuhan2020&#125;&quot;)String wuhan2020;</code></pre></li><li><p>通过**@ConfigurationProperties**读取配置信息并与 bean 绑定。可以像使用普通的 Spring bean 一样，将其注入到类中使用。</p><pre><code class="java">@Component@ConfigurationProperties(prefix = &quot;library&quot;)class LibraryProperties &#123;    @NotEmpty    private String location;    private List&lt;Book&gt; books;    @Setter    @Getter    @ToString    static class Book &#123;        String name;        String description;    &#125;  省略getter/setter  ......&#125;</code></pre></li><li><p><strong>@PropertySource</strong>读取指定 properties 文件</p><pre><code class="java">@Component@PropertySource(&quot;classpath:website.properties&quot;)class WebSite &#123;    @Value(&quot;$&#123;url&#125;&quot;)    private String url;  省略getter/setter  ......&#125;</code></pre></li></ol><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。JSR(Java Specification Requests） 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便！</p><ol><li><p>常用的字段验证的注解：</p><ul><li><p>@NotEmpty 被注释的字符串的不能为 null 也不能为空</p></li><li><p>@NotBlank被注释的字符串非 null，并且必须包含一个非空白字符</p></li><li><p>@Null 被注释的元素必须为 null</p></li><li><p>@NotNull 被注释的元素必须不为 null</p></li><li><p>@AssertTrue被注释的元素必须为 true</p></li><li><p>@AssertFalse 被注释的元素必须为 false</p></li><li><p>@Pattern(regex&#x3D;,flag&#x3D;)被注释的元素必须符合指定的正则表达式</p></li><li><p>@Email 被注释的元素必须是 Email 格式。</p></li><li><p>@Min(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值</p></li><li><p>@Max(value)被注释的元素必须是一个数字，其值必须小于等于指定的最大值</p></li><li><p>@DecimalMin(value)被注释的元素必须是一个数字，其值必须大于等于指定的最小值</p></li><li><p>@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</p></li><li><p>@Size(max&#x3D;, min&#x3D;)被注释的元素的大小必须在指定的范围内</p></li><li><p>@Digits(integer, fraction)被注释的元素必须是一个数字，其值必须在可接受的范围内</p></li><li><p>@Past被注释的元素必须是一个过去的日期</p></li><li><p>@Future被注释的元素必须是一个将来的日期</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Person &#123;    @NotNull(message = &quot;classId 不能为空&quot;)    private String classId;    @Size(max = 33)    @NotNull(message = &quot;name 不能为空&quot;)    private String name;    @Pattern(regexp = &quot;((^Man$|^Woman$|^UGM$))&quot;, message = &quot;sex 值不在可选范围&quot;)    @NotNull(message = &quot;sex 不能为空&quot;)    private String sex;    @Email(message = &quot;email 格式不正确&quot;)    @NotNull(message = &quot;email 不能为空&quot;)    private String email;&#125;</code></pre></li></ul></li><li><p>验证请求体（@RequestBody）：在需要验证的参数上加上@Valid注解，如果验证失败，它将抛出MethodArgumentNotValidException。</p><pre><code class="java">@RestController@RequestMapping(&quot;/api&quot;)public class PersonController &#123;    @PostMapping(&quot;/person&quot;)    public ResponseEntity&lt;Person&gt; getPerson(@RequestBody @Valid Person person) &#123;        return ResponseEntity.ok().body(person);    &#125;&#125;</code></pre></li><li><p>验证请求参数（Path Variables 和 Request Parameters）：一定一定不要忘记在类上加上 @Validated 注解了，这个参数可以告诉 Spring 去校验方法参数。</p><pre><code class="java">@RestController@RequestMapping(&quot;/api&quot;)@Validatedpublic class PersonController &#123;    @GetMapping(&quot;/person/&#123;id&#125;&quot;)    public ResponseEntity&lt;Integer&gt; getPersonByID(@Valid @PathVariable(&quot;id&quot;) @Max(value = 5,message = &quot;超过 id 的范围了&quot;) Integer id) &#123;        return ResponseEntity.ok().body(id);    &#125;&#125;</code></pre></li></ol><h3 id="全局处理-Controller-层异常"><a href="#全局处理-Controller-层异常" class="headerlink" title="全局处理 Controller 层异常"></a>全局处理 Controller 层异常</h3><ol><li><p><strong>@ControllerAdvice</strong> :注解定义全局异常处理类</p></li><li><p><strong>@ExceptionHandler</strong> :注解声明异常处理方法</p><p>参数校验中。如果方法参数不对的话就会抛出MethodArgumentNotValidException，可以处理这个异常。</p><pre><code class="java">@ControllerAdvice@ResponseBodypublic class GlobalExceptionHandler &#123;    /**     * 请求参数异常处理     */    @ExceptionHandler(MethodArgumentNotValidException.class)    public ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;       ......    &#125;&#125;</code></pre></li></ol><h3 id="JPA-相关"><a href="#JPA-相关" class="headerlink" title="JPA 相关"></a>JPA 相关</h3><ol><li><p>创建表：**@Entity<strong>声明一个类对应一个数据库实体。</strong>@Table** 设置表名</p><pre><code class="java">@Entity@Table(name = &quot;role&quot;)public class Role &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    private String description;    省略getter/setter......&#125;</code></pre></li><li><p><strong>@Id</strong> ：声明一个字段为主键。使用@Id声明之后，还需要定义主键的生成策略。可以使用 @GeneratedValue指定主键生成策略。JPA 使用枚举定义了 4 种常见的主键生成策略 TABLE(使用一个特定的数据库表格来保存主键,持久化引擎通过关系数据库的一张特定的表格来生成主键)、SEQUENCE(在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做序列sequence的机制生成主键)、IDENTITY(主键自增长)、AUTO(把主键生成策略交给持久化引擎(persistence engine),持久化引擎会根据数据库在以上三种主键生成 策略中选择其中一种),注解默认使用的策略是AUTO。一般使用 MySQL 数据库的话，GenerationType.IDENTITY策略比较普遍</p></li><li><p>设置字段类型：**@Column**声明字段。</p><pre><code class="java">//设置属性 userName 对应的数据库字段名为 user_name，长度为 32，非空@Column(name = &quot;user_name&quot;, nullable = false, length=32)private String userName;//设置字段类型并且加默认值，这个还是挺常用的。@Column(columnDefinition = &quot;tinyint(1) default 1&quot;)private Boolean enabled;</code></pre></li><li><p>指定不持久化特定字段:<strong>@Transient</strong> 声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库 </p><pre><code class="java">@Entity(name=&quot;USER&quot;)public class User &#123;    ......    @Transient    private String secrect; // not persistent because of @Transient&#125;//除了 @Transient关键字声明， 还可以采用下面几种方法,一般使用注解的方式比较多。static String secrect; // not persistent because of staticfinal String secrect = &quot;Satish&quot;; // not persistent because of finaltransient String secrect; // not persistent because of transient</code></pre></li><li><p>声明大字段:<strong>@Lob</strong>声明某个字段为大字段。</p><pre><code class="java">@Lob//指定 Lob 类型数据的获取策略， FetchType.EAGER 表示非延迟加载，而 FetchType.LAZY 表示延迟加载 ；@Basic(fetch = FetchType.EAGER)//columnDefinition 属性指定数据表对应的 Lob 字段类型@Column(name = &quot;content&quot;, columnDefinition = &quot;LONGTEXT NOT NULL&quot;)private String content;</code></pre></li><li><p>创建枚举类型的字段:可以使用枚举类型的字段，不过枚举字段要用**@Enumerated**注解修饰。</p><pre><code class="java">public enum Gender &#123;    MALE(&quot;男性&quot;),    FEMALE(&quot;女性&quot;);    private String value;    Gender(String str)&#123;        value=str;    &#125;&#125;@Entity@Table(name = &quot;role&quot;)public class Role &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    private String description;    @Enumerated(EnumType.STRING)    private Gender gender;    省略getter/setter......&#125;//数据库里面对应存储的是 MALE/FEMALE。</code></pre></li><li><p>删除&#x2F;修改数据:<strong>@Modifying</strong> 注解提示 JPA 该操作是修改操作,注意还要配合**@Transactional**注解使用。</p><pre><code class="java">@Repositorypublic interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123;    @Modifying    @Transactional(rollbackFor = Exception.class)    void deleteByUserName(String userName);&#125;</code></pre></li><li><p>关联关系</p><ul><li><strong>@OneToOne</strong> 声明一对一关系</li><li><strong>@OneToMany</strong>声明一对多关系</li><li><strong>@ManyToOne</strong> 声明多对一关系</li><li><strong>@MangToMang</strong> 声明多对多关系</li></ul></li><li></li></ol><h3 id="事务-Transactional"><a href="#事务-Transactional" class="headerlink" title="事务 @Transactional"></a>事务 @Transactional</h3><p>在要开启事务的方法上使用@Transactional注解即可!我们知道 Exception 分为运行时异常 RuntimeException 和非运行时异常。在@Transactional注解中如果不配置rollbackFor属性,那么事务只会在遇到RuntimeException的时候才会回滚,加上rollbackFor&#x3D;Exception.class,可以让事务在遇到非运行时异常时也回滚。@Transactional 注解一般可以作用在类或者方法上。</p><ul><li><p>作用于类：当把@Transactional&#96;注解放在类上时，表示所有该类的 public 方法都配置相同的事务属性信息。</p></li><li><p>作用于方法：当类配置了@Transactional，方法也配置了@Transactional，方法的事务会覆盖类的事务配置信息。</p><pre><code class="java">@Transactional(rollbackFor = Exception.class)public void save() &#123;  ......&#125;</code></pre></li></ul><h3 id="json-数据处理"><a href="#json-数据处理" class="headerlink" title="json 数据处理"></a>json 数据处理</h3><ol><li><p>过滤 json 数据:<strong>@JsonIgnoreProperties</strong> 作用在类上用于过滤掉特定字段不返回或者不解析。**@JsonIgnore**一般用于类的属性上，作用@JsonIgnoreProperties 一样。</p><pre><code class="java">//生成json时将userRoles属性过滤@JsonIgnoreProperties(&#123;&quot;userRoles&quot;&#125;)public class User &#123;    private String userName;    private String fullName;    private String password;    //生成json时将userRoles属性过滤    //@JsonIgnore    private List&lt;UserRole&gt; userRoles = new ArrayList&lt;&gt;();&#125;</code></pre></li><li><p>格式化 json 数据:<strong>@JsonFormat</strong>一般用来格式化 json 数据。</p><pre><code class="java">@JsonFormat(shape=JsonFormat.Shape.STRING, pattern=&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&quot;, timezone=&quot;GMT&quot;)private Date date;</code></pre></li><li><p>扁平化对象</p><pre><code class="java">@Getter@Setter@ToStringpublic class Account &#123;    private Location location;    private PersonInfo personInfo;  @Getter  @Setter  @ToString  public static class Location &#123;     private String provinceName;     private String countyName;  &#125;  @Getter  @Setter  @ToString  public static class PersonInfo &#123;    private String userName;    private String fullName;  &#125;&#125;//未扁平化之前：&#123;    &quot;location&quot;: &#123;        &quot;provinceName&quot;:&quot;湖北&quot;,        &quot;countyName&quot;:&quot;武汉&quot;    &#125;,    &quot;personInfo&quot;: &#123;        &quot;userName&quot;: &quot;coder1234&quot;,        &quot;fullName&quot;: &quot;shaungkou&quot;    &#125;&#125;//使用@JsonUnwrapped 扁平对象之后：@Getter@Setter@ToStringpublic class Account &#123;    @JsonUnwrapped    private Location location;    @JsonUnwrapped    private PersonInfo personInfo;    ......&#125;&#123;  &quot;provinceName&quot;:&quot;湖北&quot;,  &quot;countyName&quot;:&quot;武汉&quot;,  &quot;userName&quot;: &quot;coder1234&quot;,  &quot;fullName&quot;: &quot;shaungkou&quot;&#125;</code></pre></li></ol><h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3><p><strong>@ActiveProfiles</strong>:一般作用于测试类上， 用于声明生效的 Spring 配置文件。</p><p><strong>@Test</strong>:声明一个方法为测试方法</p><p><strong>@Transactional</strong>:被声明的测试方法的数据会回滚，避免污染测试数据。</p><p>**@WithMockUser **:Spring Security提供的，用来模拟一个真实用户，并且可以赋予权限。</p><pre><code class="java">@SpringBootTest(webEnvironment = RANDOM_PORT)@ActiveProfiles(&quot;test&quot;)@Slf4jpublic abstract class TestBase &#123;  ......&#125;    @Test    @Transactional    @WithMockUser(username = &quot;user-id-18163138155&quot;, authorities = &quot;ROLE_TEACHER&quot;)    void should_import_student_success() throws Exception &#123;        ......    &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;spring注解&quot;&gt;&lt;a href=&quot;#spring注解&quot; class=&quot;headerlink&quot; title=&quot;spring注解&quot;&gt;&lt;/a&gt;spring注解&lt;/h2&gt;&lt;h3 id=&quot;SpringBootApplication&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Spring" scheme="http://haolei56.github.io/categories/Spring/"/>
    
    
    <category term="spring" scheme="http://haolei56.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>pytorch使用</title>
    <link href="http://haolei56.github.io/2022/12192.html"/>
    <id>http://haolei56.github.io/2022/12192.html</id>
    <published>2022-12-19T13:28:21.346Z</published>
    <updated>2022-12-19T14:15:11.117Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Numpy基础"><a href="#Numpy基础" class="headerlink" title="Numpy基础"></a>Numpy基础</h2><p>Numpy提供了两种基本的对象： ndarray(N-dimensional Array Object)和ufunc (Universal Function Object)。 ndarray是存储单一数据类型的多维数组， 而ufunc则是 能够对数组进行处理的函数。</p><h4 id="生成ndarray的几种方式："><a href="#生成ndarray的几种方式：" class="headerlink" title="生成ndarray的几种方式："></a>生成ndarray的几种方式：</h4><ol><li><p>从已有数据中创建</p><pre><code class="python">import numpy as nplist1=[3.14,2.17,0,1,2]nd1=np.array(list1)print(nd1)#[3.14 2.17 0.   1.   2.  ]</code></pre></li><li><p>利用random 创建 ，在深度学习中， 经常需要对一些参数进行初始化， 因此为了更有效地训练模型， 提高模型的性能， 有些初始化还需要满足一定的条件， 如满足正态分布或均匀分布等。可以利用np.random模块常用的函数实现。                          </p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>np.random.random</td><td>生成0到1之间的随机数</td></tr><tr><td>np.random.uniform</td><td>生成均匀分布的随机数</td></tr><tr><td>np.random.randn</td><td>生成标准正态的随机数</td></tr><tr><td>np.random.randint</td><td>生成随机的整数</td></tr><tr><td>np.random.normal</td><td>生成正态分布</td></tr><tr><td>np.random.shuffle</td><td>随机打乱顺序</td></tr><tr><td>np.random.seed</td><td>设置随机数种子</td></tr><tr><td>random_sample</td><td>生成随机的浮点数</td></tr></tbody></table><pre><code class="import">nd1=np.random.random([3,3])#指定维数时可以用[]，也可用()，下方同理。nd2=np.random.random([4])#给定一个数据时，表示生成一行只有四个元素的数据print(nd2)#[0.85529956 0.99554336 0.20784373 0.48278592]print(nd1)#[[0.02986193 0.12572112 0.75996264]           #[0.0162905  0.23816636 0.28736631]           #[0.41927611 0.33388733 0.93705356]]print(nd1.shape)#形状为3*3的矩阵</code></pre></li><li><p>创建特定形状的多维数组</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>np.zeros((3,4))</td><td>创建3x4的元素全为0的数组</td></tr><tr><td>np.ones((3,4))</td><td>创建3x4的元素全为1的数组</td></tr><tr><td>np.empty((2,3))</td><td>创建2x3的空数组，空数据中的值并不为0,而是未初始化的垃圾值</td></tr><tr><td>np.zeros _like(ndarr)</td><td>以ndarr相同维度创建元素全为0数组</td></tr><tr><td>np.ones_like(ndarr)</td><td>以ndarr相同维度创建元素全为1数组</td></tr><tr><td>np.empty _like(ndarr)</td><td>以ndarr相同维度创建空数组</td></tr><tr><td>np.eye(5)</td><td>该函数用于创建一个5x5的单位矩阵，对角线为1,其余为0</td></tr><tr><td>np.full((3,5),666)</td><td>创建3x5的元素全为666的数组，666为指定值</td></tr><tr><td>np.diag((1,2,3))</td><td>创建对角元素为1,2,3的3维对角矩阵</td></tr></tbody></table></li><li><p>利用arange、linspace 函数生成</p><p>arange是numpy模块中的函数， 其格式为：arange ([start,] stop[,step,J, dtype (None)),其中start为开始位置，stop为结束位置，step为步长，其功能与Python内置函数range类似。</p><pre><code class="python">import numpy as np print(np.range(10)) #(0 1 2 3 4 5 6 7 8 9） print(np.arange(1, 4, 0.5)) # [1. 1.5 2. 2.5 3. 3.5] </code></pre><p>linspace也是numpy模块中常用的函数，其格式为：np.linspace(start, stop, num＝50,endpoint&#x3D;True, retstep&#x3D;False, dtype&#x3D;None),linspace可以根据输入的指定数据范围和等分数，自动生成一个线性等分向量．其中endpoint（包含终点）默认为True,等分数num默认为50。如果将retstep设置为 True,则会返回一个带步长的ndarray。</p><pre><code class="python">import numpy as npnd=np.linspace(0,1,10)#注意这里的num是等分数，不是步长，步长=(终点-起点)/(等分数-1)print(nd)#[0.         0.11111111 0.22222222 0.33333333 0.44444444 0.55555556 #0.66666667 0.77777778 0.88888889 1.] &quot;&#39;这里并没有像我们预期的那样，生成0.1,0.2,..., 1.0这样步长为0.1 的ndarray、这是因为linspace必定会包含数据起点和终点，那么其步长则为(1-0)/ 9 = 0.11111111 如果需要产生0.1,0.2,..., 1.0这样的数据，只需要将数据起点0修改为0.1即可&#39;&quot;</code></pre></li></ol><h4 id="保存数据以及恢复数据"><a href="#保存数据以及恢复数据" class="headerlink" title="保存数据以及恢复数据"></a>保存数据以及恢复数据</h4><pre><code class="python">import numpy as np nd1=np.random.random([5, 5]) np.savetxt(X=nd1, fname=&#39;./test1.txt&#39;) nd2 = np.loadtxt(&#39;./test1. txt&#39;) print(nd2) </code></pre><h4 id="获取数组中的元素值："><a href="#获取数组中的元素值：" class="headerlink" title="获取数组中的元素值："></a>获取数组中的元素值：</h4><p>索引(类似对列表和元组的操作)、函数random.choice ，从指定的样本中随机抽取数据</p><pre><code class="python">＃截取一个多维数组的一个区域内数据nd=np. arange(25). reshape([5,5]) nd[1:3,1:3] #表示读取2,3行，2,3列的公共部分</code></pre><pre><code class="python">import numpy as np a=np. arange(1,25,dtype=float) cl=random. choice (a, size= (3, 4)) #size指定输出数组形状c2=random.choice(a,size=(3,4),replace=False) #replace缺省为True,即可重复抽取。#下式中参数p指定每个元素对应的抽取概率，缺省为每个元素被抽取的概率相同 c3=random.choice(a,size=(3,4),p=a/np.sum(a)) print(“ 随机可重复抽取“ )print(cl) print(“随机但不重复抽取“ )print(c2) print( “随机但按制度概率抽取“ )print(c3) </code></pre><h4 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h4><p>逐元乘法 (Element-Wise Product)，运算符为np.multiply()或＊， 另一种是点积或内积元素 ，运算符为 np.dot()。数组通过激活函数后，输出与输入形状一致。</p><h4 id="数组变形"><a href="#数组变形" class="headerlink" title="数组变形"></a>数组变形</h4><ol><li><p>更改数组的形状：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>arr.reshape</td><td>重新将向量 arr 维度进行改变，不修改向量本身。指定维度时，参数的个数代表维度，可以只指定行数或列数， 其他用 -1代替,不能单单只指定行数或列数。且所指定的行数或列数一定要能被整除。</td></tr><tr><td>arr.resize</td><td>重新将向量 arr 维度进行改变，修改向量本身</td></tr><tr><td>arr.T</td><td>对向量arr 进行转置</td></tr><tr><td>arr.ravel</td><td>对向量 arr 进行展平，即将多维数组变成 1 维数组，不会产生原数组的副本。默认按照行优先展平，设置参数’F’，则可按照列优先展平。</td></tr><tr><td>arr. flatten</td><td>对向量 arr 进行展平，即将多维数组变成 1 维数组，返回原数组的副本</td></tr><tr><td>arr. squeeze</td><td>只能对维数为 1 的维度降维，把矩阵中维度为1的去掉。对多维数组使用时不会报错，但是不会产生任何影响</td></tr><tr><td>arr. transpose</td><td>对高维矩阵进行轴对换，比如把图片中表示颜色顺序的RGB改为GBR</td></tr></tbody></table><pre><code class="python">import numpy as np arr =np.arange(10)  ＃将向量 arr 维度变换为2行5列print(arr.reshape(2, 5)) ＃指定维度时可以只指定行数或列数， 其他用-1代替print(arr.reshape(5, -1)) print(arr.reshape(-1, 5))#arr.reshape(3,-1) 会报错，3不能被10整除arr1 =np.arange (6).reshape (2, -1)  print(＂按照列优先展平” )print (arr1.ravel (&#39;F&#39;)) print(“桉照行优先展平“ )print(arr1.ravel())arr2 =np.arange(6).reshape(3,1,2,1)#3个 高为1 的2行1列矩阵 print(arr2)[[[[0]   [1]]] [[[2]   [3]]] [[[4]   [5]]]]arr=np.arange(24).reshape(2,3,4)print(arr.shape)#(2, 3, 4)print(arr.transpose(1,2,0).shape)#(3, 4, 2)</code></pre></li><li><p>合并数组</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>np.append</td><td>内存占用大</td></tr><tr><td>np.concatenate</td><td>没有内存问题</td></tr><tr><td>np.stack</td><td>沿看新的轴加入一系列数组</td></tr><tr><td>np.hstack</td><td>堆栈数组垂直顺序（行）</td></tr><tr><td>np.vstack</td><td>堆栈数组垂直顺序（列）</td></tr><tr><td>np.dstack</td><td>堆栈数组按顺序深入（沿第 3 维）</td></tr><tr><td>np.vsplit</td><td>将数组分解成垂直的多个子数组的列表</td></tr></tbody></table><p>注：append 、 concatenate以及stack 都有一个 axis 参数， 用于控制数组的合并方式是按行还是按列。对于 append 和 concatenate, 待合并的数组必须有相同的行数或列数（满足一个即可）。stack、hstack、dstack,要求待合并的数组必须具有相同的形状(shape)。</p><pre><code class="python">import numpy as np a =np.arange(4).reshape(2, 2) b = np.arange(4).reshape(2, 2) c = np.append(a, b, axis=0)print(&#39;按行合并后的结果&#39;)print(c) print(&#39;合并后数据维度&#39;,c.shape)&#39;&#39;&#39;按行合并后的结果[[0 1] [2 3] [0 1] [2 3]]合并后数据维度 (4, 2)&#39;&#39;&#39;d = np.append(a, b, axis=1)print(&#39;按列合并后的结果&#39;)print (d) print (&#39;合并后数据维度&#39;,d.shape)&#39;&#39;&#39;按列合并后的结果[[0 1 0 1] [2 3 2 3]]合并后数据维度 (2, 4)&#39;&#39;&#39;e=np.array([[1,2],[3,4]])f=np.array([[5,6],[7,8]])print(np.stack((e,f),axis=0))#沿指定轴堆叠数组或矩阵&#39;&#39;&#39;[[[1 2]  [3 4]] [[5 6]  [7 8]]]&#39;&#39;&#39;</code></pre></li></ol><h4 id="批处理数据"><a href="#批处理数据" class="headerlink" title="批处理数据"></a>批处理数据</h4><p>得到数据集、随机打乱数据、定义批大小、批处理数据集</p><pre><code class="python">import numpy as np #生成10000个形状为2X3的矩阵,这是一个3维矩阵 ， 第1个维度为样本数， 后两个是数据形状data_train = np.random.randn(10000,2,3) #打乱这10000条数据np.random.shuffle(data_train)#定义批量大小batch_size=100#进行批处理for i in range(0,len(data_train),batch_size):    x_batch_sum=np.sum(data_train[i:i+batch_size])     print(&quot; 第&#123;&#125;批次，该批次的数据之和：&#123;&#125; &quot;.format(i,x_batch_sum))</code></pre><h4 id="通用函数（ufunc）"><a href="#通用函数（ufunc）" class="headerlink" title="通用函数（ufunc）"></a>通用函数（ufunc）</h4><p>许多ufunc函数都是用C语言级别实现的， 因此它们的计算速度非常快 此外，它们比math模块中的函数更灵活。 math模块的输入一 般是标量， 但Numpy中的函数可以是向量或矩阵， 而利用向量或矩阵可以避免使用循环语句。这点在机器学习、 深度学习中非常重要。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>sqrt</td><td>计算序列化数据的平方根</td></tr><tr><td>sin,cos</td><td>三角函数</td></tr><tr><td>abs</td><td>计算序列化数据的绝对值</td></tr><tr><td>dot</td><td>矩阵运算</td></tr><tr><td>log,log10,log2</td><td>对数函数</td></tr><tr><td>exp</td><td>指数函数</td></tr><tr><td>cumsum,cumproduct</td><td>累计求和、 求积</td></tr><tr><td>sum</td><td>对一个序列化数据进行求和</td></tr><tr><td>mean</td><td>计算均值</td></tr><tr><td>median</td><td>计算中位数</td></tr><tr><td>std</td><td>计算标准差</td></tr><tr><td>var</td><td>计算方差</td></tr><tr><td>corrcoef</td><td>计算相关系数</td></tr></tbody></table><h4 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h4><p>Numpy 的Universal functions中要求输入的数组shape是一致的， 当数组的shape不相等时，会使用广播机制调整数组的形状使其一致，但需满足一下规则：</p><ol><li><p>让所有输入数组都向其中shape最长的数组看齐，不足的部分则通过在前面加1补齐</p></li><li><p>输出数组的shape是输入数组shape的各个轴上的最大值</p></li><li><p>如果输入数组的某个轴和输出数组的对应轴的长度相同或者某个轴的长度为1时，这个数组能被用来计算， 否则出错；</p></li><li><p>当输入数组的某个轴的长度为1时， 沿着此轴运算时都用（或<strong>复制</strong>）此轴上的第一组值。</p><p>例：A+B, 其中A为4x1矩阵， B为一维向量(3,）。 要相加， 需要做如下处理：</p><ul><li>根据规则1. B需要向看齐， 把B变为(1,3)</li></ul></li></ol><ul><li>根据规则2, 输出的结果为各个轴上的最大值， 即输出结果应该为(4,3)矩阵，需要将A由(4,1)变为(4,3)矩阵， 将B由(1,3)变为(4,3)矩阵。<ul><li>根据规则4,用此轴上的第一组值（要主要区分是哪个轴）， 进行复制（但在实际处理中不是真正复制，否则太耗内存， 而是采用其他对象如ogrid对象， 进行网格处理）即可。</li></ul></li></ul><h2 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h2><p>Tensor, 它可以是零维（又称为标量或一个数）、一维、二维及多维的数组。Tensor 自称为神经网络界的 Numpy, 它与Numpy 相似，二者可以共享内存且之间的转换非常方便和高效。不过它们也有不同之处，最大的区别就是 Numpy 会把 ndarray 放在 CPU 中进行加速运算，而由torch产生的Tensor会放在GPU中进行计算。</p><h4 id="创建Tensor"><a href="#创建Tensor" class="headerlink" title="创建Tensor"></a>创建Tensor</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>Tensor(*size)</td><td>直接从参数构造一个的张量，支持List、 Numpy数组</td></tr><tr><td>eye(row, column)</td><td>创建指定行数，列数的二维单位Tensor</td></tr><tr><td>linspace(start,end,steps)</td><td>从start到end,均匀切分成steps份</td></tr><tr><td>logspace(start,end,steps)</td><td>从10^start ， 到10^end.均匀切分成steps份</td></tr><tr><td>rand&#x2F;randn(*size)</td><td>生成(0,1)均匀分布&#x2F;标准正态分布数据</td></tr><tr><td>ones(*size)</td><td>返同指定shape的张量，元素初始为1</td></tr><tr><td>zeros(*size)</td><td>返回指定shape的张量，元素初始为0</td></tr><tr><td>ones_like(t)</td><td>返回与T的shape相同的张量，且元素初始为1</td></tr><tr><td>zeros_like(t)</td><td>返同与T的shape相同的张量，且元素初始为0</td></tr><tr><td>arange(start,end.step)</td><td>在区间[start,end)上以间隔step生成一个序列张量</td></tr><tr><td>from_Numpy(ndarray)</td><td>从ndarray创建一个Tensor</td></tr></tbody></table><pre><code class="python">import torchprint(torch.Tensor([1,2,3,4,5,6]))print(torch.Tensor(2,3))#输出一个两行三列的二维矩阵，矩阵值随机t=torch.Tensor([[1,2,3],[4,5,6]])print(t)print(t.size())##shape与size(）等价print(torch.Tensor(t.size()))print(torch.linspace(1,10,4))print(torch.rand(2,3))print(torch.randn(2,3))</code></pre><p>注：torch.Tensor与torch.tensor的区别：torch. Tensor是torch.empty和torch.tensor之间的一种混合，但是， 当传入数据时，torch. Tensor使用全局默认dtype (FloatTensor)， 而torch.tensor是从数据中推断数据类型。torch.tensor(1)返回一个固定值1，而torch.Tensor(1)返回一个大小为1的张量， 它是随机初始化的值。</p><h4 id="修改Tensor形状"><a href="#修改Tensor形状" class="headerlink" title="修改Tensor形状"></a>修改Tensor形状</h4><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>size()</td><td>返回张量的shape属性值，与函数shape等价</td></tr><tr><td>numel(input)</td><td>计算Tensor的元素个数</td></tr><tr><td>view(* shape)</td><td>修改Tensor的shape,与Reshape (0.4版新增）类似，但View返回的对象与源Tensor共享内存， 修改一个，另一个同时修改。Reshape将生成新的Tensor,而且不要求源Tensor是 连续的。View(-1)展平数组</td></tr><tr><td>resize</td><td>类似于view,但在size超出时会重新分配内存空间</td></tr><tr><td>Item</td><td>若Tensor为单元素，则返回Python的标量</td></tr><tr><td>unsqueeze</td><td>在指定维度增加一个 “ 1”</td></tr><tr><td>squeeze</td><td>在指定维度压缩一个 “ 1”</td></tr></tbody></table><pre><code class="python">import torch ＃生成一个形状为2x3的矩阵x = torch.randn(2, 3) ＃查看矩阵的形状x.size() ＃结果为torch.Size([2, 3])＃查看x的维度x.dim()     ＃结果为2                    ＃把x变为3x2的矩阵                         x.view(3,2)＃把x展平为1维向量y=x.view(-1)y.shape＃添加一个维度z=torch.unsqueeze(y,0)＃查看z的形状z.size() ＃结果为torch.Size([1, 6]) ＃计算z的元素个数z.numel() ＃结果为6                         </code></pre><h4 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>index_select(input,dim,iodex)</td><td>在指定维度上选择一些行或列</td></tr><tr><td>nonzero(input)</td><td>获取非 0 元素的下标</td></tr><tr><td>masked_select(input,mask)</td><td>使用二元值进行选择</td></tr><tr><td>gather(input,dim,index)</td><td>在指定维度上选择数据，输出的形状与 index ( index 的类型必须是 LongTensor 类型的）一致</td></tr><tr><td>scatter_(input,dim,index,src)</td><td>为gather 的反操作， 根据指定索引补充数据</td></tr></tbody></table><pre><code class="python">#设置一个随机种子torch.manual_seed(100) #生成一个形状为2x3的矩阵x = torch.randn(2, 3)print(x)#根据索引获取笫1行所有数据print(x [0,: ])#获取最后一列数据print(x [:, -1])#生成是否大于0的Byter张量mask=x&gt;0 #护获取大于0的值print(torch.masked_select (x, mask))#获取非0下标，即行,列索引print(torch.nonzero(mask))#获取指定索引对应的值，输出根据以下规则得到#out [i][j] = input[index[i][j]][j] # if dim == 0 #out [i][j] = input[i][index[i][j]] # if dim == 1 index=torch.LongTensor([[0,1,1]])print(index) print(torch.gather(x,0,index)) index=torch.LongTensor([[0,1,1], [1,1, 1]]) print(index)a=torch.gather(x,1,index) print(a)#把a的值返回到一个2x3的0矩阵中z=torch.zeros(2,3) print(z)print(z.scatter_(1,index,a))&#39;&#39;&#39;tensor([[ 0.3607, -0.2859, -0.3938],        [ 0.2429, -1.3833, -2.3134]])tensor([ 0.3607, -0.2859, -0.3938])tensor([-0.3938, -2.3134])tensor([0.3607, 0.2429])tensor([[0, 0],        [1, 0]])tensor([[0, 1, 1]])tensor([[ 0.3607, -1.3833, -2.3134]])tensor([[0, 1, 1],        [1, 1, 1]])tensor([[ 0.3607, -0.2859, -0.2859],        [-1.3833, -1.3833, -1.3833]])tensor([[0., 0., 0.],        [0., 0., 0.]])tensor([[ 0.3607, -0.2859,  0.0000],        [ 0.0000, -1.3833,  0.0000]])&#39;&#39;&#39;</code></pre><h4 id="逐元素操作"><a href="#逐元素操作" class="headerlink" title="逐元素操作"></a>逐元素操作</h4><p>大部分数学运算都属于逐元索操作， 其输入与输出的形状相同 。这些操作均会创建新的 Tensor, 如果需要就地操作， 可以使用这些方法的下划线版本 ，例如x.add(y), x 的数据不变，返回一个新的 Tensor 。x.add_(y) （运行符带下划线后缀），运算结果存在 x 中，x 被修改。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>abs&#x2F;add</td><td>绝对值／加法</td></tr><tr><td>addcdiv(t, v, t1, t2)</td><td>t1与t2的按元素除后乘v加t</td></tr><tr><td>addcmul(t,v, t1, t2)</td><td>t1与12的按元素乘后乘v加t</td></tr><tr><td>ceil&#x2F;floor</td><td>向上取整／向下取整</td></tr><tr><td>clamp(t, min, max)</td><td>将张量元素限制在指定区间</td></tr><tr><td>exp&#x2F;log&#x2F;pow</td><td>指数／对数／幂</td></tr><tr><td>mul(或＊）／neg</td><td>逐元素乘法／取反</td></tr><tr><td>sigmoid&#x2F;tanh&#x2F;softmax</td><td>激活函数</td></tr><tr><td>sign&#x2F;sqrt</td><td>取符号／开根号</td></tr></tbody></table><h4 id="归并操作"><a href="#归并操作" class="headerlink" title="归并操作"></a>归并操作</h4><p>归并操作顾名思义 ， 就是对输入进行归并或合计等操作， 这类操作的输入输出形状一般并不相同 ， 而且往往是输入大于输出形状。 归并操作可以对整个 Tensor, 也可以沿着某 个维度进行归并 。归并操作一般涉及一个 dim参数，指定沿哪个维进行归并。 另一个参数是 keepdim, 说明输出结果中是否保留维度1. 缺省情况是False, 即不保留。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>cumprod(t、axis)</td><td>在指定维度对t进行累积</td></tr><tr><td>cumsum</td><td>在指定维度对t进行累加</td></tr><tr><td>dist(a,b,p&#x3D;2)</td><td>返回a,b之间的p阶范数</td></tr><tr><td>mean&#x2F;median</td><td>均值／中位数</td></tr><tr><td>std&#x2F;var</td><td>标准差／方差</td></tr><tr><td>norm(t,p&#x3D;2)</td><td>返回t的p阶范数</td></tr><tr><td>prod(t)&#x2F;sum(t)</td><td>返回t所有元素的积&#x2F;和</td></tr></tbody></table><pre><code class="python">#生成一个含6个数的向量a=torch.linspace(0,10,6) #使用view方法 把a变为2x3矩阵a=a.view ((2, 3)) print(a)#沿y轴方向累加，即dim=0b=a.sum (dim=0) print(b)#b的形状为(3)#沿y轴方向累加，即dim=0，并保留含1的维度b=a.sum(dim=0,keepdim=True) print(b)#b的形状为[1,3)&#39;&#39;&#39;tensor([[ 0.,  2.,  4.],        [ 6.,  8., 10.]])tensor([ 6., 10., 14.])tensor([[ 6., 10., 14.]])&#39;&#39;&#39;</code></pre><h4 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h4><p>比较操作一般是进行逐元素比较， 有些是按指定方向比较。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>eq</td><td>比较Tensor是否相等． 支持broadcast</td></tr><tr><td>equal</td><td>比较Tensor是否有相同的shape与值</td></tr><tr><td>ge&#x2F;le&#x2F;gt&#x2F;lt</td><td>大于／小于比较／大于等于／小于等于比较</td></tr><tr><td>max&#x2F;min(t,axis)</td><td>返回最值， 若指定axis, 则额外返回下标</td></tr><tr><td>topk(t,k,axis)</td><td>在指定的axis维上取最高的K个值</td></tr></tbody></table><h4 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>dot(t1, t2 )</td><td>计算张量(1D)的内积或点积</td></tr><tr><td>mm(mat1, mat2)&#x2F;bmm(batch1,batch2)</td><td>计算矩阵乘法／含batch的3D矩阵乘法</td></tr><tr><td>mv(t1 ，v1)</td><td>计算矩阵与向量乘法</td></tr><tr><td>t</td><td>转置</td></tr><tr><td>svd(t)</td><td>计算t的SVD分解</td></tr></tbody></table><p>注： Torch的dot 与Numpy的dot有点不同，Torch中的dot是对两个为1D张量进行点积运算，Numpy中的dot无此限制。mm是对2D的矩阵进行点积，bmm对含batch的3D进行点积运算。转置运算会导致存储空间不连续，需要调用contiguous方法转为连续。</p><h4 id="Autograd-自动求导"><a href="#Autograd-自动求导" class="headerlink" title="Autograd(自动求导)"></a>Autograd(自动求导)</h4><ol><li><p>对于表达式：z&#x3D; wx + b。可写成两个表示式： y&#x3D; wx, 则z &#x3D; y + b, 其中x、 W、b为变量， 是用户创建的变量， 不依赖于其他变量， 故又称为叶子节点。 y、z是计算得到的变量， 是非叶子节点，z为根节点。</p></li><li><p>步骤：</p><ul><li><p>创建叶子节点 (Leaf Node) 的 Tensor 、使用 requires_grad 参数指定是否记录对其的操作， 以便之后利用 backward(）方法进行梯度求解。 requires_grad 参数的缺省值为 False。 如果要对其求导需设置为 True, 然后与之有依赖关系的节点会自动变为 True。</p></li><li><p>通过运算创建的 Tensor 得到非叶子节点， 会自动被赋予 grad_fn 属性，该属性表示梯度函数。叶子节点的 grad_fn 为 None。最后得到的 Tensor 执行 backward( ）函数，此时自动计算所有叶子节点的梯度，并将累加结果保存到grad属性中，计算完成后， 非叶子节点的梯度自动释放。</p></li><li><p>backward()函数需要接收参数，该参数应和调用backward(）函数的Tensor 的维度相同， 或者是可broadcast 的维度。如果求导的Tensor 为标量（即一个数字）， 则backward中的参数可省略。反向传播的中间缓存会被清空，如果需要进行多次反向传播， 需要指定backward中的参数retain _graph&#x3D;True 。多次反向传播时， 梯度是累加的。非叶子节点的梯度backward调用后即被清空。</p></li><li><p>可利用 requires_grad_（）方法修改 Tensor 的 requires_grad 属性。可以调用 .detach() 或 with torch.no_grad() :， 将不再计算张量的梯度， 跟踪张量的历史记录。也可以通过用torch.no_grad(）包裹代码块的形式来阻止autograd去跟踪那些标记为.requesgrad&#x3D;True 的张量的历史记录，这些在评估模型、 测试模型阶段中常常用到。</p><pre><code class="python">import torch #定义输入张量xx=torch.Tensor((2))print(x) #初始化权重参数w，偏移量b、井设置require_grad属性为True,为自动求导w=torch.randn(1,requires_grad=True) b=torch.randn(1,requires_grad=True) print(w)print(b)#实现前向传播y=torch.mul(w,x) #等价于w*x z=torch.add(y,b) #等价于y+b#查看x,w, b页子节点的requite_grad属性print(&quot;x,w,b的require_grad属性分别为： &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;. format (x.requires_grad, w.requires_grad,b.requires_grad)) #查看非叶子节点的requres_grad属性，print(&quot;y, z的requires_grad属性分别为： &#123;&#125;，&#123;&#125; &quot;.format(y.requires_grad,z.requires_grad)) #因与w, b有依赖关系，故y, z的requires_grad属性也是: True, True #查看各节点是否为叶子节点print (&quot;x, w, b, y, z的是否为叶子节点： &#123;&#125;，&#123;&#125;，&#123;&#125;，&#123;&#125;，&#123;&#125; &quot; . format (x.is_leaf,w.is_leaf,b.is_leaf,y.is_leaf,z.is_leaf)) #x, w. b. y, z的是否为叶子节点：True,True,True,False,False#查看叶子节点的grad_fn属性print (&quot;x, w, b的grad_fn属性： &#123;&#125;，&#123;&#125;，&#123;&#125;&quot;.format(x.grad_fn,w.grad_fn,b.grad_fn)) #因x, w, b为用户创建的，为通过其他张量计算得到，故x, w, b的grad_fn属性:None,None,None #查看非叶子节点的grad_fn属性print (&quot;y, z的是否为叶子节点： &#123;&#125;，&#123;&#125; &quot;.format (y.grad_fn, z. grad_fn)) #基于z张量进行梯度反向传播，执行backward之后计算图会自动清空 ．z.backward(torch.ones_like(z))#如果想要多次使用backward,需要修改参数retain_graph为True,此时梯度是累加的#z.backward(retain_graph=True)#查看叶子节点的梯度， x是叶子节点但它无须求导，故其梯度为Noneprint(&quot;参数w,b的梯度分别为： &#123;&#125;，&#123;&#125;，&#123;&#125;&quot;.format(w.grad,b.grad,x.grad)) #参数w,b的梯度分别为：tensor ([ 2. I), tensor ([ 1. ]), None #非叶子节点的梯度，执行backward之后，会自动清空print(&quot;非叶子节点y,z的梯度分别为：&#123;&#125;，&#123;&#125;&quot;.format(y.grad,z.grad))&quot;&quot;&quot;tensor([0., 0.])tensor([-0.0008], requires_grad=True)tensor([-1.3176], requires_grad=True)x,w,b的require_grad属性分别为： False, True, Truey, z的requires_grad属性分别为： True，True x, w, b, y, z的是否为叶子节点： True，True，True，False，False x, w, b的grad_fn属性： None，None，Noney, z的是否为叶子节点： &lt;MulBackward0 object at 0x0000020D9C9BBA58&gt;，&lt;AddBackward0 object at 0x0000020D9C9BBB38&gt; 参数w,b的梯度分别为： tensor([0.])，tensor([2.])，None非叶子节点y,z的梯度分别为：None，None&quot;&quot;&quot;</code></pre></li></ul></li><li><p>使用Tensor及Antograd实现机器学习示例</p><pre><code class="python">import torch as t %matplotlib inline from matplotlib import pyplot as plt #生成训练数据， 并可视化数据分布情况t.manual_seed(100)dtype = t.float#生成x坐标数据，x为tenor, 需要把x的形状转换为100x1x = t.unsqueeze(t.linspace(-1, 1, 100), dim=1)#生成y坐标数据，y为tenor, 形状为100x1, 另加上一些噪声y = 3*x.pow(2) +2+ 0.2*t.rand(x.size())#画图，把tensor数据转换为numpy数据plt.scatter(x.numpy(), y.numpy()) plt.show() #初始化权重参数。 #随机初始化参数，参数w、b为需要学习的，故需requires_grad=Truew=t.randn(1,1, dtype=dtype,requires_grad=True)b = t.zeros(1,1, dtype=dtype, requires_grad=True)#训练模型lr =0.001 #学习率for ii in range (800):     #前向传播并定义损失函数loss    y_pred= x.pow(2).mm(w) + b    loss =0.5 * (y_pred - y) ** 2    loss = loss. sum ()     #自动计算梯度，梯度存放在grad属性中     loss. backward ()     #手动更新参数需要用torch.no _grad()使上下文环境中切断自动求导的计算    with t.no_grad():         w -= lr * w.grad         b -= lr * b.grad        #梯度清零        w.grad.zero_()         b.grad.zero_()#可视化训练结果。plt.plot(x.numpy(), y_pred.detach().numpy(),&#39;r-&#39;,label=&#39;predict&#39;)#predictplt.scatter (x. numpy (), y. numpy (),color=&#39;blue&#39;, marker=&#39;o&#39;, label= &#39;true&#39;) #true data plt.xlim(-1,1) plt.ylim(2,6) plt. legend () plt.show () print(w, b) </code></pre></li></ol><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><p>层、模型（层构成的网络）、损失函数、优化器。PyTorch 的 nn 工具箱，可以构建一个神经网络实例。 nn 中对这些组件都有现成包或类， 可以直接使用， 非常方便。构建网络层可以基于 Module 类或函数 (nn.functional) 。 nn 中的大多数层 (Layer) 在 functional 中都有与之对应的函数。 nn.functional 中函数与 nn.Module 中的 Layer 的主要区别是后者继承 Module 类， 会自动提取可学习的参数。 而 nn.functional 更像是纯函数。 两者功能相同， 且性能也没有很大区别， 像卷积层、 全连接层、 Dropout 层等因含有可学习参数， 一般使用 nn.Module, 而激活函数、 池化层不含可学习参数， 可以使用 nn.functional 中对应的函数。 </p><p><img src="C:\Users\haolei\AppData\Roaming\Typora\typora-user-images\1651736202552.png" alt="PyTorch实现神经网络主要工具及相互关系"></p><h4 id="神经网络实例"><a href="#神经网络实例" class="headerlink" title="神经网络实例"></a>神经网络实例</h4><pre><code class="python">import numpy as np import torch import matplotlib.pyplot as plt %matplotlib inline #导入PyTorch内置的mnist数据from torchvision.datasets import mnist #导入预处理模块import torchvision.transforms as transformsfrom torch.utils.data import DataLoader#导入nn及优化器import torch.nn.functional as F import torch.optim as optim from torch import nn #定义一些超参数train_batch_size=64test_batch_size=128learning_rate= 0.01 num_epoches = 20 lr = 0.01 momentum = 0.5 #定义预处理函数，这些预处理依次放在Compose函数中 transforms.Compose可以把一些转换函数组合在一起；#Normalize([0.5], [0.5]）对张量进行归一化，这里两个0.5分别表示对张量进行归一化的全局平均值和方差。因图像是灰色的只有一个通道，如果有多个通道，需要有多个数字．如3个通道，应该是Normalize([ml,m2,m3],[nl,n2,n3]); transform = transforms.Compose([transforms.ToTensor (), transforms.Normalize ([0.5], [0.5])])#下载数据并对数据进行预处理。download参数控制是否需要下载，如果．/data目录下已有MNIST,可选择False;train_dataset = mnist.MNIST(&#39;./data&#39;, train=True, transform=transform, download=True) test_dataset= mnist.MNIST(&#39;./data&#39;,train=False, transform=transform)#dataloader是一个可迭代对象， 可以使用迭代器一样使用。用DataLoader得到生成器，这可节省内存；train_loader = DataLoader(train_dataset,batch_size=train_batch_size, shuffle=True)test_loader =DataLoader(test_dataset, batch_size=test_batch_size,shuffle=False)#可视化源数据examples= enumerate(test_loader) batch_idx, (example_data, example_targets) = next(examples)fig= plt.figure()for i in range(6):    plt.subplot (2, 3, i +1)     plt.tight_layout ()     plt.imshow(example_data[i][0], cmap=&#39;gray&#39;, interpolation=&#39;none&#39;)     plt.title (&quot;Ground Truth: &#123;&#125;&quot;. format (example_targets [i]))     plt.xticks([])     plt.yticks([]) #构建网络模型class Net(nn.Module):    #使用sequential构建网络，Sequential()函数的功能是将网络的层组合到一起    def __init__(self,in_dim, n_hidden_1, n_hidden_2, out_dim):         super(Net,self).__init__()        self.layerl = nn.Sequential(nn.Linear(in_dim,n_hidden_1),nn.BatchNorm1d(n_hidden_1))         self.layer2 = nn.Sequential(nn.Linear(n_hidden_1, n_hidden_2),nn.BatchNorm1d(n_hidden_2))         self.layer3 = nn.Sequential(nn.Linear(n_hidden_2, out_dim))    #forward函数的任务需要把输入层、网络层、输出层链接起来 ，实现信息的前向传导。该函数的参数一般为输入数据，返回值为输出数据。    def forward(self, x):         x = F.relu(self.layerl(x))         x = F.relu(self.layer2(x))        x = self.layer3(x)         return x #检测是否有可用的GPU,有则使用，否则使用CPU#如果希望用GPU训练，需要把模型、训练数据、测试数据发送到 GPU上， 即调用.to(device)device= torch.device(&quot;cuda:0&quot; if torch.cuda.is_available() else &quot;cpu&quot;) #实例化网络model = Net(28 * 28, 300, 100, 10) model.to(device)#定义损失函数和优化器criterion= nn.CrossEntropyLoss () optimizer= optim.SGD(model.parameters(), lr=lr, momentum=momentum) #开始训练losses = [] acces = [] eval_losses=[]eval_acces=[] for epoch in range(num_epoches):    train_loss = 0     train_acc= 0     #训练模型时需要注意使模型处于训练模式，即调用model.train() 。调用model.train()会把所有的module设置为训练模式。     #如果是测试或验证阶段，需要使模型处于验证阶段 ，即调用model.eval(),调用model.eval会把所有的training属性设置为False 。    model.train ()     #动态修改参数学习率    if epoch%5==0:         optimizer. param_groups[0][&#39;lr&#39;] *=0.1     for img, label in train_loader:         img=img.to(device)         label = label.to(device)        img =img.view(img.size(0), -1)        #前向传播        out = model (img)         loss = criterion(out, label)         #反向传播        #缺省情况下梯度是累加的，需要手工把梯度初始化或清零，调用optimizer.zero_grad()即可。         optimizer.zero_grad()         loss.backward ()         #使用optimizer.step()执行优化器        optimizer.step ()         #记录误差        train_loss += loss.item()         #计算分类的准确率        _,pred = out.max(1)         num_correct = (pred == label).sum().item()         acc = num_correct / img.shape[0]         train_acc += acc losses.append(train_loss / len(train_loader)) acces.append(train_acc/ len(train_loader)) #在测试集上检验效果eval_loss = 0 eval_acc = 0 #将模型改为预测模式model.eval() for img, label in test_loader:    img=img.to(device)     label = label.to(device)     img = img.view(img.size(0), -1)     out = model (img)     loss = criterion(out, label)     #记录误差    eval_loss += loss.item()    #记录准确率    _, pred= out.max(1)    num_correct= (pred ==label).sum().item()    acc =num_correct /img.shape[0]    eval_acc += acc eval_losses.append(eval_loss / len(test_loader)) eval_acces.append(eval_acc / len(test_loader)) print (&#39;epoch: &#123;&#125;, Train Loss: &#123;:.4f&#125;, Train Acc: &#123;:.4f&#125;, Test Loss: &#123;:.4f&#125;, Test Acc: &#123;:.4f&#125;&#39;.format(epoch, train_loss / len(train_loader), train_acc / len(train_loader),eval_loss / len(test_loader), eval_acc / len(test_loader)))plt.title(&#39;trainloss&#39;) plt.plot(np.arange(len(losses)), losses) plt.legend([&#39;Train Loss&#39;], loc=&#39;upper right&#39;)</code></pre><h4 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h4><p>在深度学习学习中，过滤器也是需要通过模型训练来得到。卷积神经网络主要目的就是计算出这些filter的数值。设输入数据大小为n，填充为p,过滤器大小为f，步幅大小为s，则卷积后的大小为：$$(n+2p-f)&#x2F;s+1$$</p><ol><li><p>通常Pytorch的卷积运算是通过nn.Conv2d来完成。</p><pre><code class="python">torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True, padding_mode=&#39;zeros&#39;)&quot;&quot;&quot;dilation(int or tuple, optional)卷积核元素之间的间距groups(int, optional)控制输入和输出之间的连接： group=1，输出是所有的输入的卷积；group=2，此时相当于有并排的两个卷积层，每个卷积层计算输入通道的一半，并且产生的输出是输出通道的一半，随后将这两个输出连接起来。bias(bool, optional)如果bias=True，添加偏置。其中参数kernel_size，stride,padding，dilation也可以是一个int的数据，此时卷积height和width值相同;也可以是一个tuple数组，tuple的第一维度表示height的数值，tuple的第二维度表示width的数值&quot;&quot;&quot;</code></pre></li><li><p>池化(Pooling)又称下采样 ，池化层比卷积层更简单， 它没有卷积运算， 只是在滤波器算子滑动区域内取最大值或平均值。 池化的作用则体现在降采样：保留显著特征、 降低特征维度， 增大感受野。常用的池化方式通常有3种：</p><ul><li>最大池化(Max Pooling)：选择Pooling窗口中的最大值作为采样值</li><li>均值池化(Mean Pooling)：将Pooling窗口中的所有值相加取平均， 以平均值作为采样值。</li><li>全局最大（或均值）池化： 与平常最大或最小池化相对而言， 全局池化是对整个特征图的池化而不是在移动窗口范围内的池化。</li></ul><p>在PyTorch中， 最大池化常使用nn.MaxPool2d,平均池化使用nn.AvgPool2d。</p><pre><code class="python">torch.nn.MaxPool2d(kernel_size, stride=None, padding=O, dilation=l, return indices=False, ceil_mode=False) &quot;&quot;&quot;kemel_size :池化窗口的大小．取一个4维向址，一般是(height,width)，如果两者相等，可以是一个数字.stride：窗口在每一个维度上滑动的步长，一般也是(stride_b,stride_w)，如果两者相等，可以是一个数字&quot;&quot;&quot;</code></pre></li></ol><p>下例是由卷积层(Conv2d)、池化层(MaxPool2d)和全连接层(Linear)叠加而成一个比较简单的卷积神经网络。</p><pre><code class="python">class CNNNet(nn.Module):    def __init__(self):        super(CNNNet,self).__init__()        self.conv1 = nn.Conv2d(in_channels=3,out_channels=16,kernel_size=5,stride=1)        self.pool1 = nn.MaxPool2d(kernel_size=2,stride=2)        self.conv2 = nn.Conv2d(in_channels=16,out_channels=36,kernel_size=3,stride=1)        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)        self.fc1 = nn.Linear(1296,128)        self.fc2 = nn.Linear(128,10)           def forward(self,x):        x=self.pool1(F.relu(self.conv1(x)))        x=self.pool2(F.relu(self.conv2(x)))        #print(x.shape)        x=x.view(-1,36*6*6)        x=F.relu(self.fc2(F.relu(self.fc1(x))))        return x</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Numpy基础&quot;&gt;&lt;a href=&quot;#Numpy基础&quot; class=&quot;headerlink&quot; title=&quot;Numpy基础&quot;&gt;&lt;/a&gt;Numpy基础&lt;/h2&gt;&lt;p&gt;Numpy提供了两种基本的对象： ndarray(N-dimensiona</summary>
      
    
    
    
    <category term="Pytorch" scheme="http://haolei56.github.io/categories/Pytorch/"/>
    
    
    <category term="pytorch" scheme="http://haolei56.github.io/tags/pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://haolei56.github.io/2022/12195.html"/>
    <id>http://haolei56.github.io/2022/12195.html</id>
    <published>2022-12-19T13:28:21.341Z</published>
    <updated>2022-12-19T14:14:11.857Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h5 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h5><ol><li><p>Python 通常是一行写完一条语句，因此，语句不需要以；结束。但如需在同一行中使用多条语句，语句之间使用分号 <strong>;</strong> 分割。如果语句很长，可以使用反斜杠 \来实现多行语句，在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \。</p></li><li><p>使用缩进来表示代码块，不需要使用大括号 {} 。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。缩进相同的一组语句构成一个代码块，称之为代码组。像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码就构成了代码组。将首行及后面的代码组称为一个子句(clause)。</p><pre><code class="python">if True:    print (&quot;Answer&quot;)    print (&quot;True&quot;)else:    print (&quot;Answer&quot;)  print (&quot;False&quot;)    # 缩进不一致，会导致运行错误</code></pre></li></ol><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><ol><li><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。下例中，[1,2,3] 是 List 类型，”str1” 是 String 类型，而变量 a 是没有类型，它仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p><pre><code class="python">a=[1,2,3]a=&quot;str1&quot;</code></pre></li><li><p>变量命名：第一个字符必须是字母或下划线， 其他的部分由字母、数字和下划线组成，且区分大小写。python3中可以用中文作为变量名，非 ASCII 标识符也是允许的。</p></li><li><p>Python可以同时为多个变量赋值。例如：a&#x3D;b&#x3D;c&#x3D;1，本例中，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。</p></li><li><p>也可以为多个对象指定多个变量。例如：a, b, c &#x3D; 1, 2, “c”</p><pre><code class="python">a, b = b, a+b#上式会先把右边的表达式全计算完成后，在统一向左边变量赋值，如下：#n=b#m=a+b#a=n#b=m</code></pre></li></ol><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Python3 中有六个标准的数据类型：Number（数字）、String（字符串）、Tuple（元组）、List（列表）、Set（集合）、Dictionary（字典）。其中前三个是不可变数据（不能直接改变其中的某位的值，重新赋值，将重新分配内存空间），后三个是可变数据。</p><h5 id="数字类型（Number）"><a href="#数字类型（Number）" class="headerlink" title="数字类型（Number）"></a>数字类型（Number）</h5><ol><li><p>python中数字有四种类型：整数、布尔型、浮点数和复数（用的是j而不是i）。在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p><pre><code class="python">a=1;b=Truec=1.3d=2+3j#或者complex(2,3)</code></pre></li><li><p>内置的 type() 函数可以用来查询变量所指的对象类型。此外还可以用 isinstance 来判断。isinstance 和 type 的区别在于，type()不会认为子类是一种父类类型，isinstance()会认为子类是一种父类类型</p><pre><code class="python">a,b,c,d=1,1.2,True,1+2jprint(type(a),type(b),type(c),type(d))#输出&lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;bool&#39;&gt; &lt;class &#39;complex&#39;&gt;print(isinstance(a,int))#输出True</code></pre></li><li><p>Python3 中，bool 是 int 的子类，True 和 False 可以和数字相加，True&#x3D;1、False&#x3D;0 ;但不可以通过is 来判断类型。</p></li><li><p>对象就会被创建后，可以使用del语句删除一些对象引用。如：var &#x3D; 1；del var</p></li><li><p>数值运算：+（加）、-（减）、*（乘）、&#x2F;（除）、&#x2F;&#x2F;（取整）、%（取余）、**（乘方）。在混合计算时，Python会把整型转换成为浮点数。 复数的实部和虚部也都是浮点型。</p></li><li><p>数字函数</p><table><thead><tr><th align="center">函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td align="center">abs(x)</td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td align="center">fabs(x)</td><td>返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td align="center">ceil(x)</td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td align="center">cmp(x,y)</td><td>如果 x &lt; y 返回 -1, 如果 x &#x3D;&#x3D; y 返回 0, 如果 x &gt; y 返回 1。 Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换。</td></tr><tr><td align="center">exp(x)</td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td align="center">floor(x)</td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td align="center">log(x)</td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td align="center">log10(x)</td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td align="center">max(x1,x2,…)</td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td align="center">min(x1,x2,…)</td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td align="center">modf(x)</td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td align="center">pow(x, y)</td><td>x**y 运算后的值。</td></tr><tr><td align="center">round(x[,n]）</td><td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。</td></tr><tr><td align="center">sqrt(x)</td><td>返回数字x的平方根。</td></tr></tbody></table></li><li><p>随机数函数</p><table><thead><tr><th align="center">函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td align="center">choice(seq)</td><td>从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td align="center">randrange ([start,] stop [,step])</td><td>从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1</td></tr><tr><td align="center">random()</td><td>随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td align="center">seed([x])</td><td>改变随机数生成器的种子seed。不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td align="center">shuffle(lst)</td><td>将序列的所有元素随机排序</td></tr><tr><td align="center">uniform(x, y)</td><td>随机生成下一个实数，它在[x,y]范围内。</td></tr></tbody></table></li><li><p>三角函数：sin(x),cos(x),tan(x),asin(x),acos(x),atan(x)</p><table><thead><tr><th align="center">函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td align="center">atan2(y, x)</td><td>返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td align="center">hypot(x, y)</td><td>返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td></tr><tr><td align="center">degrees(x)</td><td>将弧度转换为角度,如degrees(math.pi&#x2F;2) ， 返回90.0</td></tr><tr><td align="center">radians(x)</td><td>将角度转换为弧度</td></tr></tbody></table></li><li><p>数学常量:pi 圆周率，一般以π来表示 。e即自然常数。</p></li></ol><h5 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h5><ol><li><p>Python 中单引号 <strong>‘</strong> 和双引号 <strong>“</strong> 使用完全相同。使用三引号（’’’或”””）可以指定一个多行字符串。与注释不同，注释前面没有变量名和等号。</p><pre><code class="python">string=&#39;这是一个字符串&#39;str=&quot;这是一个字符串&quot;s=&#39;&#39;&#39;这是多行字符串，这是第二行字符串&#39;&#39;&#39;</code></pre></li><li><p>反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义。 如 r”this is a line with \n”则 \n 会显示，并不是换行。</p></li><li><p>字符串连接：可以使用+连接，还可以按字面意义连接。*运算符可重复显示。</p><pre><code class="python">e=&quot;this&quot;+&quot; &quot;+&quot;is&quot;&quot;a&quot;&quot;String&quot;print(e*2)</code></pre></li><li><p>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1开始（-1，-2，-3…）。字符串的截取的语法格式如下：变量[头下标:尾下标:步长]。遵循左闭右开的原则，如果第三个参数为负数表示逆向读取。</p><pre><code class="python">a=&quot;1234567890&quot;print(a[0:2])#12print(a[0:-1])#123456789print(a[-1:])#0print(a[-3:-1])#89print(a[0:7:2])#1357</code></pre></li><li><p>Python 中的字符串不能改变。即无法直接修改字符串的某一位字符。但可对该字符变量重新赋值。</p><pre><code class="python">a=&quot;1234567890&quot;a[3]=9print(a)#会报错a=&quot;12&quot;print(a)#输出12</code></pre></li><li><p>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</p></li><li><p>格式化输出：</p><ul><li><p>%</p><pre><code class="python">print(&quot;%s今年%d岁了&quot;%(&quot;小明&quot;,10))</code></pre></li><li><p>格式化字符串函数 str.format()，基本语法是通过 {} 和 : 来代替以前的 %。format 函数可以接受不限个参数，位置可以不按顺序。</p><pre><code class="python">print(&quot;&#123;&#125;&#123;&#125;&quot;.format(&quot;str1&quot;,&quot;str2&quot;))#str1str2print(&quot;&#123;1&#125;&#123;0&#125;&#123;1&#125;&quot;.format(&quot;str1&quot;,&quot;str2&quot;))#str2str1str2</code></pre></li><li><p>f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。f-string 格式化字符串以 f开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去。这种方式明显更简单了，不用再去判断使用 %s，还是 %d。</p><pre><code class="python">a=&quot;str1&quot;print(f&quot;&#123;1+2&#125;&quot;)#3print(f&quot;&#123;a&#125;&quot;)#str1</code></pre></li></ul></li></ol><h5 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h5><ol><li><p>列表是写在方括号 []之间、用逗号分隔开的元素列表。列表是 Python 中使用最频繁的数据类型。列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p></li><li><p>列表也可以被索引和截取，列表被截取后返回一个包含所需元素的新列表，截取方式和字符串相同。</p></li><li><p>List可以使用+操作符进行拼接，*操作符进行重复。List中的元素是可以改变的。</p></li><li><p>列表中的主要函数或方法</p><table><thead><tr><th align="center">函数或方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">len(list)</td><td>列表元素个数</td></tr><tr><td align="center">max(list)</td><td>返回列表元素最大值</td></tr><tr><td align="center">min(list)</td><td>返回列表元素最小值</td></tr><tr><td align="center">list(seq)</td><td>将元组转换为列表</td></tr><tr><td align="center">list.append(obj)</td><td>在列表末尾添加新的对象</td></tr><tr><td align="center">list.count(obj)</td><td>统计某个元素在列表中出现的次数</td></tr><tr><td align="center">list.extend(seq)</td><td>在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td></tr><tr><td align="center">list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="center">list.index(obj)</td><td>从列表中找出某个值第一个匹配项的索引位置</td></tr><tr><td align="center">list.pop([index&#x3D;-1])</td><td>移除列表中的一个元素（默认最后一个元素），并且返回该元素的值从列表的指定位置移除元素，并将其返回。</td></tr><tr><td align="center">list.remove(obj)</td><td>移除列表中某个值的第一个匹配项</td></tr><tr><td align="center">list.reverse()</td><td>反向列表中元素</td></tr><tr><td align="center">list.sort( key&#x3D;None, reverse&#x3D;False)</td><td>对原列表进行排序</td></tr><tr><td align="center">list.clear()</td><td>清空列表</td></tr><tr><td align="center">list.copy()</td><td>复制列表</td></tr></tbody></table></li><li><p>列表方法使得列表可以很方便的作为一个<strong>堆栈</strong>来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。</p></li></ol><h5 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h5><ol><li><p>元组写在小括号 () 里（不需要括号也可以），元素之间用逗号隔开。元组与列表类似，相关操作也几乎相同，不同之处在于元组的元素不能修改。元组中的元素值是不允许删除的。</p></li><li><p>虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p></li><li><p>构造包含 0 个或 1 个元素的元组比较特殊，语法规则如下：</p><pre><code class="python">tup1 = ()    # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号，否则括号会被当作运算符使用tup=&quot;a&quot;,1,3,&quot;b&quot;,&quot;c&quot;,2print(tup)#(&#39;a&#39;, 1, 3, &#39;b&#39;, &#39;c&#39;, 2)</code></pre></li><li><p>元组内置函数：len(tuple)、max(tuple)、min(tuple)、tuple(iterable)</p></li></ol><h5 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h5><ol><li><p>集合是一个<strong>无序的不重复</strong>元素序列。可以使用大括号 { }或者 set()函数创建集合，注意：创建一个空集合必须用 set()而不是 { }，因为 { }是用来创建一个空字典的。</p></li><li><p>构成集合的事物或对象称作元素或成员。集合的基本功能是进行成员关系测试和删除重复元素。</p></li><li><p>set可以进行集合运算</p><pre><code class="python">a=set(&#39;abr22+2j2.2dbra&#39;)b=&#123;&#39;a&#39;,2+2j,&#39;b&#39;,2,&#39;a&#39;,&#39;z&#39;&#125;print(a)#&#123;&#39;+&#39;, &#39;a&#39;, &#39;2&#39;, &#39;j&#39;, &#39;r&#39;, &#39;.&#39;, &#39;d&#39;, &#39;b&#39;&#125;print(b)#&#123;2, (2+2j), &#39;z&#39;, &#39;a&#39;, &#39;b&#39;&#125;print(a - b)     # a 和 b 的差集print(a | b)     # a 和 b 的并集print(a &amp; b)     # a 和 b 的交集print(a ^ b)     # a 和 b 中不同时存在的元素(并集去掉交集)</code></pre></li><li><p>集合内置方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">add()</td><td>为集合添加元素</td></tr><tr><td align="center">clear()</td><td>移除集合中的所有元素</td></tr><tr><td align="center">copy()</td><td>拷贝一个集合</td></tr><tr><td align="center">difference()</td><td>返回多个集合的差集</td></tr><tr><td align="center">difference_update()</td><td>移除集合中的元素，该元素在指定的集合也存在。</td></tr><tr><td align="center">discard()</td><td>删除集合中指定的元素</td></tr><tr><td align="center">intersection()</td><td>返回集合的交集</td></tr><tr><td align="center">intersection_update()</td><td>返回集合的交集。</td></tr><tr><td align="center">isdisjoint()</td><td>判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。</td></tr><tr><td align="center">issubset()</td><td>判断指定集合是否为该方法参数集合的子集。</td></tr><tr><td align="center">issuperset()</td><td>判断该方法的参数集合是否为指定集合的子集</td></tr><tr><td align="center">pop()</td><td>随机移除元素</td></tr><tr><td align="center">remove()</td><td>移除指定元素</td></tr><tr><td align="center">symmetric_difference()</td><td>返回两个集合中不重复的元素集合。</td></tr><tr><td align="center">symmetric_difference_update()</td><td>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。</td></tr><tr><td align="center">union()</td><td>返回两个集合的并集</td></tr><tr><td align="center">update()</td><td>给集合添加元素，且参数可以是列表，元组，字典等</td></tr></tbody></table></li></ol><h5 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h5><ol><li><p>字典是无序的对象集合,列表是有序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典是一种映射类型，字典用 { }标识，它是一个无序的 键(key) : 值(value)的集合。键(key)必须使用不可变类型（可以用数字，字符串或元组充当）。在同一个字典中，键(key)必须是唯一的。</p><pre><code class="python">dict=&#123;&#125;dict[1]=&#39;一号元素值&#39;#赋值操作dict[&#39;2&#39;]=&#39;二号元素值&#39;print(dict)#&#123;1: &#39;一号元素值&#39;, &#39;2&#39;: &#39;二号元素值&#39;&#125;dict1 = &#123;&#39;name&#39;: &#39;菜鸟&#39;,2:1, &#39;site&#39;: &#39;www.cainiao.com&#39;&#125;print(dict1.keys())print(dict1.values())</code></pre></li><li><p>不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会覆盖前一个的值。</p></li><li><p>字典中的主要函数或方法</p><table><thead><tr><th align="center">函数或方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">len(dict)</td><td>计算字典元素个数，即键的总数。</td></tr><tr><td align="center">str(dict)</td><td>输出字典，可以打印的字符串表示。</td></tr><tr><td align="center">dict.clear()</td><td>删除字典内所有元素</td></tr><tr><td align="center">dict.copy()</td><td>返回一个字典的浅复制</td></tr><tr><td align="center">dict.fromkeys(seq)</td><td>创建一个新字典，以序列seq中元素（如果是字典，则是取键值）做新字典的键，val为字典所有键对应的初始值（一般为空）</td></tr><tr><td align="center">dict.get(key, default&#x3D;None)</td><td>返回指定键的值，如果键不在字典中返回 default 设置的默认值</td></tr><tr><td align="center">key in dict</td><td>如果键在字典dict里返回true，否则返回false</td></tr><tr><td align="center">dict.items()</td><td>以列表返回一个视图对象</td></tr><tr><td align="center">dict.keys()</td><td>返回一个视图对象</td></tr><tr><td align="center">dict.setdefault(key, default&#x3D;None)</td><td>和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td></tr><tr><td align="center">dict.update(dict2)</td><td>把字典dict2的键&#x2F;值对更新到dict里</td></tr><tr><td align="center">dict.values()</td><td>返回一个视图对象</td></tr><tr><td align="center">pop(key[,default])</td><td>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td></tr><tr><td align="center">popitem()</td><td>返回并删除字典中的最后一对键和值。</td></tr></tbody></table></li></ol><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ol><li><p>隐式数据类型转换：对两种不同类型的数据进行运算，较低数据类型（整数）就会转换为较高数据类型（浮点数）以避免数据丢失。</p></li><li><p>显示数据类型转换：显示转换中，只需要将数据类型作为函数名即可。如 int()、float()、str() 等。</p></li></ol><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><p>Python 推导式是一种独特的数据处理方式，可以从一个数据序列构建另一个新的数据序列的结构体。</p><ol><li><p>列表推导式：[表达式 for 变量 in 某种数据序列] 或者 [表达式 for 变量 in 某种数据序列 if 条件]</p><pre><code class="python">multiples = [i for i in range(30) if i % 3 == 0]print(multiples)#计算 30 以内可以被 3 整除的整数</code></pre></li><li><p>字典推导式:{ 新字典的key: 新字典的值 for 值（key或value） in 某种数据序列 }</p><pre><code class="python">dic = &#123;x: x**2 for x in (2, 4, 6)&#125;#&#123;2: 4, 4: 16, 6: 36&#125;</code></pre></li><li><p>集合推导式:{ 表达式 for 项 in 某种数据序列 }</p><pre><code class="python">a = &#123;x for x in &#39;abracadabra&#39; if x not in &#39;abc&#39;&#125;</code></pre></li><li><p>元组推导式:元组推导式和列表推导式的用法也完全相同，只是元组推导式是用 ()圆括号将各部分括起来，而列表推导式用的是中括号 []，另外元组推导式返回的结果是一个生成器对象。</p><pre><code class="python">a = (x for x in range(1,10))</code></pre></li></ol><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ol><li><p>算术运算符、比较运算符、赋值运算符、位运算符与其他语言类似。Pyhton3 已不支持 &lt;&gt; 运算符，可以使用 !&#x3D; 代替。</p></li><li><p>Python语言支持逻辑运算符：and，or，not（and 优先级高于or，not优先级最高）</p><pre><code class="python">x=10y=20print(x and y)# 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。print(x or y)#如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。print(not x)#如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</code></pre></li><li><p>成员运算符：in，not in</p></li><li><p>身份运算符：is，is not。 id() 函数用于获取对象内存地址。is运算符与id()函数功能类似。is 与 &#x3D;&#x3D; 区别：is 用于判断两个变量引用对象是否为同一个， &#x3D;&#x3D; 用于判断引用变量的值是否相等。</p></li></ol><h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><ol><li><p>结构：Python 中用 elif代替了 else if，所以if语句的关键字为：if – elif – else。</p><pre><code class="python">if condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3</code></pre></li><li><p>在Python中没有switch – case语句。</p></li></ol><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h5 id="while"><a href="#while" class="headerlink" title="while"></a>while</h5><ol><li><p>while或while  else 结构（条件为True是执行while，为false是执行else）</p><pre><code class="python">if condition_1:    statement_block_1elif condition_2:    statement_block_2else:    statement_block_3</code></pre></li><li><p>在 Python 中没有 do..while 循环。</p></li></ol><h5 id="for"><a href="#for" class="headerlink" title="for"></a>for</h5><ol><li><p>for循环可以遍历任何可迭代对象，如一个列表或者一个字符串。for循环的一般格式如下：</p><pre><code class="python">for &lt;variable&gt; in &lt;sequence&gt;:    &lt;statements&gt;else:    &lt;statements&gt;</code></pre></li><li><p>**break **和 **continue **语句及循环中的 else 子句</p><p>break语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p><p>循环语句可以有 else 子句，也可以没有，当其存在时它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。</p></li><li><p>for和while区分：for用来遍历完一个列表，而while可以进行判断。</p></li><li><p><strong>pass</strong>:pass是空语句，是为了保持程序结构的完整性。pass 不做任何事情，一般用做占位语句。</p><pre><code class="python">while True:    pass  # 等待键盘中断 (Ctrl+C)class EmptyClass:    pass</code></pre></li></ol><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><ol><li><p>迭代是Python最强大的功能之一，是访问序列元素的一种方式。字符串，列表或元组对象都可用于创建迭代器，迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()<strong>。迭代器是一个可以</strong>记住遍历的位置</strong>的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><pre><code class="python">list1=[1,2,3,4]it=iter(list1)print(next(it))#1print(next(it))#2for i in it:    print(i)#3,4</code></pre></li><li><p>**StopIteration **异常用于标识迭代的完成，防止出现无限循环的情况</p><pre><code class="python">import sys         # 引入 sys 模块list=[1,2,3,4]it = iter(list)    # 创建迭代器对象while True:    try:        print (next(it))    except StopIteration:        sys.exit()</code></pre></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ol><li><p>函数代码块以 <strong>def</strong> 关键词开头，后接函数名称和圆括号 ()。任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。函数内容以冒号 <strong>:</strong> 起始，并且缩进。return [表达式]结束函数，选择性地返回一个值给调用方，不带表达式的 return 相当于返回 None。</p><pre><code class="python">def 函数名（参数列表）:    函数体</code></pre></li><li><p>函数的参数传递：不可变类型：类似 C++ 的值传递，如整数、字符串、元组。如 fun(a)，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象。可变类型：类似 C++ 的引用传递，如 列表，字典。如 fun(la)，则是将 la 真正的传过去，修改后 fun 外部的 la 也会受影响。python 中一切都是对象，严格意义不能说值传递还是引用传递，应该说传不可变对象和传可变对象。</p></li><li><p>参数：必需参数、关键字参数、默认参数、不定长参数</p><pre><code class="python">def func(a,b):    print(a)    print(b)func(1,&quot;str1&quot;)#必需参数def func(a,b,c=1):    print(a)    print(b)    print(c)func(b=2,a=1,c=3)#a,b为关键字参数，c有默认参数#b,c为不定长参数，加一个星号 * 的参数会以元组的形式导入，加两个星号 ** 的参数会以字典的形式导入def func1(a,*b,**c):    print(a)#1    print(b)#（1,2,3）    print(c)#&#123;&#39;e&#39;: 1, &#39;f&#39;: 2&#125;func1(1,2,3,4,e=1,f=2)#声明函数时，参数中星号 * 可以单独出现，如果单独出现，星号 * 后的参数必须用关键字传入。def func2(a,b,*,c):    return a+b+cfunc2(1,2,c=3)#Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。下例中，形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参def f(a, b, /, c, d, *, e, f):    print(a, b, c, d, e, f)f(10, 20, 30, d=40, e=50, f=60)</code></pre></li><li><p>匿名函数：Python 使用 <strong>lambda</strong> 来创建匿名函数。 lambda 函数只有一行，lambda 的主体是一个表达式，而不是一个代码块。函数体比 def简单很多，仅仅能在 lambda 表达式中封装有限的逻辑进去。lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</p><pre><code class="python">lambda [arg1 [,arg2,.....argn]]:expressionsum = lambda arg1, arg2: arg1 + arg2sum( 10, 20 )</code></pre></li></ol><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ol><li><p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。导入模块的方式：</p><pre><code class="python">import module1[, module2[,... moduleN]#直接使用模块名即可，不用加.py后缀（方括号表示这个参数是可选的，而不是要求输入一对方括号，后面用到的地方类似）</code></pre></li><li><p>可以使用模块名称来访问模块内部定义的函数：模块名.函数名，也可以直接导入模块函数,这种导入在访问函数时就不需要加前缀了。</p><pre><code class="python">from modname import name1[, name2[, ... nameN]]</code></pre></li><li><p>一次性的把模块中的所有（函数，变量）名称都导入到当前模块，这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p><pre><code class="python">from modname import *</code></pre></li><li><p>**__name__<strong>属性:一个模块被另一个程序第一次引入时，其主程序(main方法)将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用__name__属性来使该程序块仅在该模块自身运行时执行。每个模块都有一个__name__属性，当其值是</strong>‘__main__‘**时，表明该模块自身在运行，否则是被引入。其中：__name__ 与 __main__底下是双下划线。if  __name__ &#x3D;&#x3D; ‘__main__‘的意思是：当.py文件被直接运行时，if __name__ &#x3D;&#x3D; ‘__main__‘之下的代码块将被运行；当.py文件以模块形式被导入时，if  __name__ &#x3D;&#x3D; ‘__main__‘之下的代码块不被运行。</p><pre><code class="python">#const.py文件PI = 3.14def main():    print(&quot;PI:&quot;, PI)main()# 运行结果：PI: 3.14#area.py文件from const import PIdef calc_round_area(radius):    return PI * (radius ** 2)def main():    print(&quot;round area: &quot;, calc_round_area(2))main()&#39;&#39;&#39;运行结果：PI: 3.14round area:  12.56&#39;&#39;&#39;#在const.py文件加上if语句，运行area.py时就不会输出PI: 3.14PI = 3.14def main():    print(&quot;PI:&quot;, PI)if __name__ == &quot;__main__&quot;:    main()</code></pre></li><li><p><strong>dir()</strong>:内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回</p></li><li><p>包：目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。最简单的情况，放一个空的 file:__init__.py就可以了。当然这个文件中也可以包含一些初始化代码或者为 __all__变量赋值。如果包定义文件 __init__.py 存在一个叫做 __all__的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。通常不主张使用 * 这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。使用 from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p></li></ol><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ol><li><p>Python两种输出值的方式: 表达式语句和 print() 函数。第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。如果你希望将输出的值转成字符串， str() 函数来实现。str()：函数返回一个用户易读的表达形式。</p></li><li><p>repr()：产生一个解释器易读的表达形式。repr() 的参数可以是 Python 的任何对象</p><pre><code class="python">x=3y=&quot;3&quot;z=&quot;3\n&quot;print(repr(x))#3print(repr(y))#&#39;3&#39;print(repr(z))#repr() 函数可以转义字符串中的特殊字符,输出&#39;3\n&#39;</code></pre></li><li><p>读取键盘输入：input</p><pre><code class="python">a=input(&quot;请输入a得值，按enter键退出&quot;)print(a)</code></pre></li><li><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end&#x3D;””</p></li></ol><h3 id="文件-File"><a href="#文件-File" class="headerlink" title="文件(File)"></a>文件(File)</h3><ol><li><p>打开文件**open()**，返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。open() 函数常用形式是接收两个参数：文件名(file)和模式(mode）。</p><pre><code class="python">open(file, mode=&#39;r&#39;)#完整格式open(file, mode=&#39;r&#39;, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)#file: 必需，文件路径（相对或者绝对路径）。#mode: 可选，文件打开模式#buffering: 设置缓冲#encoding: 一般使用utf8#errors: 报错级别#newline: 区分换行符#closefd: 传入的file参数类型#opener: 设置自定义开启器，开启器的返回值必须是一个打开的文件描述符。</code></pre></li><li><p>mode的参数：</p><table><thead><tr><th align="center">模式</th><th>r</th><th>r+</th><th>w</th><th>w+</th><th>a</th><th>a+</th></tr></thead><tbody><tr><td align="center">读</td><td>+</td><td>+</td><td></td><td>+</td><td></td><td>+</td></tr><tr><td align="center">写</td><td></td><td>+</td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td align="center">文件不存在时会创建</td><td></td><td></td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td align="center">原文件有内容时会被覆盖</td><td></td><td></td><td>+</td><td>+</td><td></td><td></td></tr><tr><td align="center">指针在开始</td><td>+</td><td>+</td><td>+</td><td>+</td><td></td><td></td></tr><tr><td align="center">指针在结尾</td><td></td><td></td><td></td><td></td><td>+</td><td>+</td></tr></tbody></table><p>注：模式后的加表示即可读也可写。其中r是默认值，a用于追加文件内容，所写的任何数据都会被自动增加到末尾，默认为文本模式，如果要以二进制模式打开，在相应模式后加上 <strong>b</strong> ，如rb+。</p></li><li><p>常用方法</p><table><thead><tr><th align="center">方法</th><th>描述</th></tr></thead><tbody><tr><td align="center">file.close()</td><td>关闭文件。关闭后文件不能再进行读写操作。</td></tr><tr><td align="center">file.flush()</td><td>刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td></tr><tr><td align="center">file.readline([size])</td><td>读取整行，包括 “\n” 字符。如果返回一个空字符串, 说明已经已经读取到最后一行。</td></tr><tr><td align="center">file.readlines([sizeint])</td><td>读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。</td></tr><tr><td align="center">file.read([size])</td><td>从文件读取指定的字节数，如果未给定或为负则读取所有。</td></tr><tr><td align="center">file.write(str)</td><td>将字符串写入文件，返回的是写入的字符长度。如果要写入一些不是字符串的东西, 那么需要使用str()函数先进行转换</td></tr><tr><td align="center">file.tell()</td><td>返回文件当前位置。它是从文件开头开始算起的字节数。</td></tr><tr><td align="center">file.seek(offset[, whence])</td><td>移动文件读取指针到指定offset位置。whence的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符 ；seek(x,1) ： 表示从当前位置往后移动x个字符 seek(-x,2)：表示从文件的结尾往前移动x个字符</td></tr><tr><td align="center">file.truncate([size])</td><td>从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。</td></tr><tr><td align="center">file.writelines(sequence)</td><td>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td></tr><tr><td align="center">file.isatty()</td><td>如果文件连接到一个终端设备返回 True，否则返回 False。</td></tr><tr><td align="center">file.fileno()</td><td>返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td></tr></tbody></table></li><li><p>当处理一个文件对象时, 使用 <strong>with 关键字</strong>是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短</p><pre><code class="python">with open(&quot;D://Markdown入门.md&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;) as f:    print(f.read())</code></pre></li><li><p><strong>序列化（pickle模块）</strong>：通过pickle模块的序列化操作能够将程序中运行的对象信息保存到文件中去，永久存储。通过pickle模块的反序列化操作，能够从文件中创建上一次程序保存的对象。</p><pre><code class="python">import picklepickle.dump(obj, file, [,protocol])#将对象保存到文件中x = pickle.load(file)#从文件中读取对象</code></pre></li></ol><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ol><li><p><strong>try&#x2F;except</strong> ：类似java中的try&#x2F;catch，首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。如果没有异常发生，忽略 except 子句，try 子句执行后结束。如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。最后一个except子句可以忽略异常的名称，它将被当作通配符使用。可以使用这种方法打印一个错误信息，然后再次把异常抛出。</p><pre><code class="python">try :    passexcept (RuntimeError, TypeError, NameError):    passexcept OSError as err:    passexcept:    print(&quot;Unexpected error:&quot;, sys.exc_info()[0])    raise</code></pre></li><li><p>try&#x2F;except 语句还有一个可选的 <strong>else</strong> 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。</p><p>else 子句将在 try 子句没有发生任何异常的时候执行。使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。</p><pre><code class="python">try:    #执行代码    passexcept TypeError:    #发生异常时执行    passelse:    #没发生异常时执行    pass</code></pre></li><li><p>异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理try子句中调用的函数（甚至间接调用的函数）里抛出的异常。</p></li><li><p><strong>try-finally</strong> 语句无论是否发生异常都将执行最后的finally代码。</p></li><li><p><strong>抛出异常(raise)</strong>:类似java中的throw。用 raise 语句抛出一个指定的异常。raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p><pre><code class="python">raise [Exception [, args [, traceback]]]</code></pre></li><li><p>如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住（没有匹配的异常），那么这个异常会在 finally 子句执行后被抛出。</p><pre><code class="python">try:    raise KeyboardInterruptfinally:    print(&#39;Goodbye, world!&#39;)Goodbye, world!Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;KeyboardInterrupt</code></pre></li><li><p><strong>assert（断言）</strong>:用于判断一个表达式，在表达式条件为 false 的时候直接抛出异常。断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况。</p><pre><code class="python">assert expression [, arguments]#等价于if not expression:    raise AssertionError(arguments)</code></pre></li></ol><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ol><li><p><strong>class</strong>：</p><pre><code class="python">class MyClass:    &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot;    i = 12345    def f(self):        return &#39;hello world&#39; # 实例化类x = MyClass() # 访问类的属性和方法print(&quot;MyClass 类的属性 i 为：&quot;, x.i)print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f())</code></pre></li><li><p><strong>self</strong>:代表类的实例，而非类，类似java中的this，类的方法与普通的函数只有一个特别的区别——它们<strong>必须有一个额外的第一个参数名称</strong>，习惯上用 self表示，其实也可以是其他名称，但必须保证类中一致。self 代表的是类的实例，代表当前对象实例的地址，而 self.class 则指向类。</p><pre><code class="python">class Test:    def function(self):        print(self)#&lt;__main__.Test object at 0x000002262EDDACC8&gt;        print(self.__class__)#&lt;class &#39;__main__.Test&#39;&gt;t = Test()t.function()</code></pre></li><li><p><strong>类的属性和方法</strong>：</p><ul><li><p>类的私有属性:__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。</p></li><li><p>类的私有方法:__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。</p></li></ul></li><li><p>**构造方法__init__() **:该方法在类实例化时会自动调用</p><pre><code class="python">def __init__(self):    passclass Complex:    def __init__(self, realpart, imagpart):        self.r = realpart        self.i = imagpartx = Complex(3.0, -4.5)print(x.r, x.i)   # 输出结果：3.0 -4.5</code></pre></li><li><p><strong>继承</strong>:Python 支持类的继承。而且是多继承。子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。</p><pre><code class="python">class DerivedClassName(BaseClassName):#基类与派生类定义在同一个作用域内时    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;class DerivedClassName(modname.BaseClassName):  #基类定义在另一个模块中时      passclass DerivedClassName(Base1, Base2, Base3):    &lt;statement-1&gt;    .    .    .    &lt;statement-N&gt;</code></pre><ul><li><p>方法重写：如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法。super() 函数是用于调用父类(超类)的一个方法。</p><pre><code class="python">class Parent:        # 定义父类   def myMethod(self):      print (&#39;调用父类方法&#39;) class Child(Parent): # 定义子类   def myMethod(self):      print (&#39;调用子类方法&#39;) c = Child()          # 子类实例c.myMethod()         # 子类调用重写方法，输出调用子类方法super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法，输出调用父类方法</code></pre></li><li><p>继承时的构造函数：如果在子类中需要父类的构造方法就需要显式地调用父类的构造方法，或者不重写父类的构造方法。子类不重写 __init__，实例化子类时，会自动调用父类定义的 __init__。如果重写了__init__ 时，实例化子类，就不会调用父类已经定义的 __init__。如果重写了__init__ 时，要继承父类的构造方法，可以使用 super关键字：super(子类，self).__init__(参数1，参数2，….)，还有一种经典写法：</p><p>父类名称.__init__(self,参数1，参数2，…)</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;基础语法&quot;&gt;&lt;a href=&quot;#基础语法&quot; class=&quot;headerlink&quot; title=&quot;基础语法&quot;&gt;&lt;/a&gt;基础语法&lt;/h3&gt;&lt;h5 id=&quot;代码格式&quot;&gt;&lt;a href=&quot;#代码格式&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="Python" scheme="http://haolei56.github.io/categories/Python/"/>
    
    
    <category term="Python" scheme="http://haolei56.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>java框架技术</title>
    <link href="http://haolei56.github.io/2022/12191.html"/>
    <id>http://haolei56.github.io/2022/12191.html</id>
    <published>2022-12-19T13:28:21.330Z</published>
    <updated>2022-12-19T14:13:18.999Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul><li><p><strong>优点：</strong>  省去JDBC中Connection, Statement, ResultSet 等辅助操作，减少了访问不同表时的代码雷同。我们只需要关注在增删改查等操作层面上，而把技术细节都封装在了我们看不见的地方。</p></li><li><p><strong>原理：</strong>应用程序通过mybatis从数据库中找来数据。通过mybatis-config.xml 定位数据库，执行Category.xml对应的SQL语句，基于Category.xml把得到的数据库记录封装在Category对象或集合中返回。</p></li><li><p><strong>配置文件mybatis-config.xml</strong></p></li></ul><pre><code class="java">  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;  &lt;!DOCTYPE configuration          PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;          &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;  &lt;configuration&gt;      &lt;typeAliases&gt;          &lt;package name=&quot;bean&quot;/&gt;&lt;!--实体类所在的包名--&gt;      &lt;/typeAliases&gt;      &lt;environments default=&quot;development&quot;&gt;          &lt;environment id=&quot;development&quot;&gt;              &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;              &lt;dataSource type=&quot;POOLED&quot;&gt;                  &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;                  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql:///how2java?serverTimezone=Asia/Shanghai&quot;/&gt;                  &lt;property name=&quot;username&quot; value=&quot;个人的数据库名称&quot;/&gt;                  &lt;property name=&quot;password&quot; value=&quot;个人的数据库密码&quot;/&gt;              &lt;/dataSource&gt;          &lt;/environment&gt;      &lt;/environments&gt;      &lt;mappers&gt;          &lt;mapper resource=&quot;bean/Category.xml&quot;/&gt;&lt;!--.xml文件所在的位置，一般与对应实体类在一起--&gt;          &lt;mapper resource=&quot;bean/Product.xml&quot;/&gt;      &lt;/mappers&gt;  &lt;/configuration&gt;</code></pre><p>  1.以上6-8行是别名，自动扫描bean下的类型，使得在后续配置文件Category.xml中使用resultType的时候，可以直接使用Category,而不必写全bean.Category</p><ul><li><p><strong>配置文件Category.xml</strong></p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;bean&quot;&gt;&lt;!--xml文件所在包--&gt;    &lt;insert id=&quot;addCategory&quot; parameterType=&quot;Category&quot;&gt;        insert into category_ (name) value (#&#123;name&#125;)    &lt;/insert&gt;    &lt;delete id=&quot;deleteCategory&quot; parameterType=&quot;Category&quot;&gt;        delete from category_ where id=#&#123;id&#125;    &lt;/delete&gt;    &lt;select id=&quot;getCategory&quot; parameterType=&quot;int&quot; resultType=&quot;Category&quot;&gt;        select * from category_ where id=#&#123;id&#125;    &lt;/select&gt;    &lt;update id=&quot;updateCategory&quot; parameterType=&quot;Category&quot; &gt;        update category_ set name=#&#123;name&#125; where id=#&#123;id&#125;    &lt;/update&gt;    &lt;select id=&quot;listCategory&quot; resultType=&quot;Category&quot;&gt;        select * from category_    &lt;/select&gt;&lt;/mapper&gt;</code></pre></li><li><p><strong>mybatis中#{}和${}的区别：</strong></p><p>#{}: 表示一个占位符号?,#{}可以有效防止SQL注入。如果parameterType传进来的是基本类型，也就是(string,long,double,int,boolean,float等)，那么#{}里面的变量名可以随意写，比如abc,xxx等等，这个名字和传进来的参数名可以不一致。如果传进来的是简单Java对象类型（pojo），那么#{}中的变量名必须是pojo的属性名，可以写成属性名,也可以写属性名.属性名，但不能写成类名.属性名。例如insert into student(name,age,score) values(#{Student.name},#{Student.age},#{Student.score})会将Student当成一个属性而报错。</p><p>${}  :Statement 把 sql 语句和${}的内容拼接起来。主要用在替换表名，列名，不同列排序等操作。不能防止sql注入，mybatis中使用它相当于不做单引号任何处理，使用另外的场景也有模糊查询 like  ‘%${name}%’。</p><p>#{}和${}中的值均代表一个变量时，均会取变量对应的值代替，不同的是，#{}解析之后会将String类型的数据自动加上引号，其他数据类型不会；${}解析之后是什么就是什么，他不会当做字符串处理。如：order by #{id}，传入的值为abc，解析后的SQL为order by ‘abc’。如：order by ${id}，传入的值为abc，解析后的SQL为order by abc。</p></li><li><p><strong>resultMap结果集：</strong>将数据库中列数据复制到对象的相应属性上，可以用于复制查询。resultMap是Mybatis最强大的元素，它可以将查询到的复杂数据（比如查询到几个表中数据）映射到一个结果集当中。</p><p>使用resultType进行输出映射，只有查询出来的列名和pojo（实体bean）中的属性名一致，该列才可以映射成功。简单来说也就是数据库字段和JavaBean里的字段名称必须一致才能映射成功。</p><p>当我们JavaBean中的字段名和数据库字段名称有不同的时候，或者是多表查询的时候，一般会使用resultMap </p><pre><code class="java">&lt;resultMap id=&quot;唯一的标识&quot; type=&quot;映射的实体类（Category）&quot;&gt;     &lt;id column=&quot;数据库中的主键或者对应的别名&quot; jdbcType（可省略）=&quot;字段类型&quot; property=&quot;对      应实体类的属性名&quot;/&gt;     &lt;result column=&quot;数据库中表的字段或别名(可以为任意的一个字段，无顺序)&quot; jdbcType=&quot;字段类      型&quot; property=&quot;对应实体类的属性名&quot;/&gt;          &lt;!--多对一时使用--&gt;     &lt;association property=&quot;实体类中对应的属性名（如category）&quot;javaType=&quot;一对应的实体类&quot;&gt;         &lt;id column=&quot;关联实体类对应数据库中表的主键字段或别名&quot; jdbcType=&quot;字段类型&quot;                  property=&quot;对应实体类的属性名&quot;/&gt;         &lt;result column=&quot;数据库中表的字段或别名(可以为任意的一个字段，无顺序)&quot; jdbcType=&quot;字          段类型&quot; property=&quot;对应实体类的属性名&quot;/&gt;     &lt;/association&gt;         &lt;!--一对多时使用--&gt;     &lt;collection property=&quot;实体类的集合属性(Category实体类中的集合属性products)&quot;               ofType=&quot;集合中的元素类型（Product）&quot;&gt;          &lt;id column=&quot;集合实体对象对应的数据库中的主键或别名&quot; jdbcType=&quot;字段类型&quot;          property=&quot;集合实体类的对应属性&quot; /&gt;          &lt;result column=&quot;集合实体对象对应的数据库中表的一个字段或别名(可以为任意的一个字段)&quot;           jdbcType=&quot;字段类型&quot; property=&quot;集合实体类的对应属性&quot; /&gt;     &lt;/collection&gt;&lt;/resultMap&gt;</code></pre><p>举例说明：</p><pre><code class="java">//一对多时//Category类对应的属性：public class Category &#123;    private int id;    private String name;    List&lt;Product&gt; products; &#125;//对应的resultMap: &lt;resultMap id=&quot;categoryBean&quot; type=&quot;Category&quot;&gt;        &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;        &lt;collection property=&quot;products&quot; ofType=&quot;Product&quot;&gt;            &lt;id column=&quot;pid&quot; property=&quot;id&quot;/&gt;          &lt;result  column=&quot;pname&quot; property=&quot;name&quot;/&gt;            &lt;result column=&quot;price&quot; property=&quot;price&quot;/&gt;        &lt;/collection&gt;  &lt;/resultMap&gt;//多对一时//Product类对应的属性：public class Product &#123;    private int id;    private String name;    private float price;    private Category category;&#125;//对应的resultMap： &lt;resultMap id=&quot;productBean&quot; type=&quot;Product&quot;&gt;        &lt;id column=&quot;pid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;pname&quot; property=&quot;name&quot;/&gt;        &lt;result column=&quot;price&quot; property=&quot;price&quot;/&gt;        &lt;association property=&quot;category&quot; javaType=&quot;Category&quot;&gt;            &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt;        &lt;/association&gt; &lt;/resultMap&gt;         //多对多时：//例如：一张订单里可以包含多种产品，一种产品可以出现在多张订单里。这就是多对多关系。//为了维系多对多关系，必须要一个中间表。这里使用订单项(OrderItem)表来作为中间表。//Order类对应属性：public class Order &#123;    private int id;    private String code;    List&lt;OrderItem&gt; orderItems;&#125;//OrderItem类对应属性：public class OrderItem &#123;    private int id;    private int number;    private Order order;    private Product product;&#125;//对应的resultMap：&lt;!--查询结果中id和code字段放在Order对象里，然后通过一对多的&lt;collection&gt;标签把oiid和number放在OrderItem对象里，最后把pid,pname,price放进Product对象里。--&gt;&lt;!--查询的结果为一个Order类型的结果集，需要通过Order对象取出对应的其他orderItems和product数据--&gt;    &lt;resultMap type=&quot;Order&quot; id=&quot;orderBean&quot;&gt;        &lt;id column=&quot;oid&quot; property=&quot;id&quot;/&gt;        &lt;result column=&quot;code&quot; property=&quot;code&quot;/&gt;        &lt;collection property=&quot;orderItems&quot; ofType=&quot;OrderItem&quot;&gt;            &lt;id column=&quot;oiid&quot; property=&quot;id&quot;/&gt;            &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;            &lt;!--多对一，一个产品可以出现在多个不同的订单项中--&gt;            &lt;association property=&quot;product&quot; javaType=&quot;Product&quot;&gt;                &lt;id column=&quot;pid&quot; property=&quot;id&quot;/&gt;                &lt;result column=&quot;pname&quot; property=&quot;name&quot;/&gt;                &lt;result column=&quot;price&quot; property=&quot;price&quot;/&gt;            &lt;/association&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;</code></pre></li><li><p><strong>动态SQL</strong></p><p>使用Mybatis 动态SQL可以减少代码行，便于维护。</p><ul><li>if标签：如果没有传参数name,那么就查询所有，如果有name参数，那么就进行模糊查询。</li></ul><pre><code class="java">&lt;select id=&quot;listProduct&quot; resultType=&quot;Product&quot;&gt;    select * from product    &lt;if test=&quot;name!=null&quot;&gt;        where name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)    &lt;/if&gt;             &lt;/select&gt;</code></pre><ul><li><p>where标签：标签会进行自动判断，如果任何条件都不成立，那么sql语句里就不会出现where关键字<br>如果有任何条件成立，会自动去掉多出来的 and 或者 or。</p><pre><code class="java">&lt;select id=&quot;listProduct&quot; resultType=&quot;Product&quot;&gt;    select * from product    &lt;where&gt;        &lt;if test=&quot;name!=null&quot;&gt;            and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)        &lt;/if&gt;                     &lt;if test=&quot;price!=null and price!=0&quot;&gt;            and price &gt; #&#123;price&#125;        &lt;/if&gt;        &lt;/where&gt;         &lt;/select&gt;</code></pre></li><li><p>set标签：与where标签类似的，在update语句里可以使用set对多个字段进行判断设置。</p><pre><code class="java"> &lt;update id=&quot;updateProduct&quot; parameterType=&quot;Product&quot; &gt;        update product        &lt;set&gt;            &lt;if test=&quot;name != null&quot;&gt;name=#&#123;name&#125;,&lt;/if&gt;            &lt;if test=&quot;price != null&quot;&gt;price=#&#123;price&#125;&lt;/if&gt;         &lt;/set&gt;         where id=#&#123;id&#125;       &lt;/update&gt;</code></pre></li><li><p>when otherwise标签：Mybatis里面没有else标签，可以使用when otherwise标签来达到这样的效果。</p><pre><code class="java">&lt;select id=&quot;listProduct&quot; resultType=&quot;Product&quot;&gt;              SELECT * FROM product              &lt;where&gt;                &lt;choose&gt;                  &lt;when test=&quot;name != null&quot;&gt;                    and name like concat(&#39;%&#39;,#&#123;name&#125;,&#39;%&#39;)                  &lt;/when&gt;                            &lt;when test=&quot;price !=null and price != 0&quot;&gt;                    and price &gt; #&#123;price&#125;                  &lt;/when&gt;                                  &lt;otherwise&gt;                    and id &gt;1                  &lt;/otherwise&gt;                &lt;/choose&gt;              &lt;/where&gt;&lt;/select&gt;</code></pre></li><li><p>foreach标签：通常用于in 语法里</p><pre><code class="java">&lt;select id=&quot;listProduct&quot; resultType=&quot;Product&quot;&gt;          SELECT * FROM product            WHERE ID in                &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;                    open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;                    #&#123;item&#125;                &lt;/foreach&gt;&lt;/select&gt;</code></pre></li><li><p>bind标签：类似字符串拼接，方便后续使用。</p><pre><code class="java">&lt;select id=&quot;listProduct&quot; resultType=&quot;Product&quot;&gt;            &lt;bind name=&quot;likename&quot; value=&quot;&#39;%&#39; + name + &#39;%&#39;&quot; /&gt;            select * from   product_  where name like #&#123;likename&#125;&lt;/select&gt;</code></pre></li></ul></li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul><li><p>Spring是一个基于IOC和AOP的结构J2EE系统的框架。</p></li><li><p><strong>IOC(Inversion Of Control)</strong> ：反转控制是Spring的基础，简单说就是创建对象由以前的程序员自己new 构造方法来调用，变成了交由Spring创建对象。当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。DI (Dependency Inject)依赖注入. 简单地说就是拿到的对象的属性，已经被注入好相关值了(类似已经初始化了)，直接使用即可。</p></li><li><p>**AOP(Aspect Oriented Program)**：面向切面编程。首先，在面向切面编程的思想里面，把功能分为核心业务功能(登陆，增加数据，删除数据等)和周边功能(性能统计，日志，事务管理等)。在Spring的AOP思想里，周边功能被定义为切面。核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 “编织” 在一起，这种能够选择性的，低耦合的把切面和核心业务功能结合在一起的编程思想，就叫做切面编程</p></li><li><p>spring的配置文件：<strong>applicationContext.xml</strong></p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;   http://www.springframework.org/schema/beans   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd   http://www.springframework.org/schema/aop   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd   http://www.springframework.org/schema/tx   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd   http://www.springframework.org/schema/context   http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;pojo&quot;/&gt;    &lt;context:component-scan base-package=&quot;aspect&quot;/&gt;    &lt;context:component-scan base-package=&quot;service&quot;/&gt;    &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;</code></pre></li></ul><h2 id="Spring-mvc"><a href="#Spring-mvc" class="headerlink" title="Spring mvc"></a>Spring mvc</h2><p>mvc模型，实现网页交互。 SpringMVC会自动检测类发生的变化，但是web.xml做的改动必须重启tomcat才可以看到效果。</p><ul><li><p>配置文件springMvc.xml</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd         http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package=&quot;controller&quot;&gt;          &lt;context:include-filter type=&quot;annotation&quot;           expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;    &lt;/context:component-scan&gt;    &lt;mvc:annotation-driven /&gt;    &lt;mvc:default-servlet-handler /&gt;    &lt;bean        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;        &lt;property name=&quot;viewClass&quot;            value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt;        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre></li><li><p>web.xml</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;    &lt;servlet&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;servlet-class&gt;            org.springframework.web.servlet.DispatcherServlet        &lt;/servlet-class&gt;        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;    &lt;servlet-mapping&gt;        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;        &lt;url-pattern&gt;/&lt;/url-pattern&gt;    &lt;/servlet-mapping&gt;    &lt;filter&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;        &lt;init-param&gt;            &lt;param-name&gt;encoding&lt;/param-name&gt;            &lt;param-value&gt;utf-8&lt;/param-value&gt;        &lt;/init-param&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;</code></pre></li><li><p>原理</p><p>   1.用户访问 &#x2F;index</p><ol start="2"><li>根据web.xml中的配置 所有的访问都会经过DispatcherServlet</li><li>根据 根据配置文件springMvc.xml ，访问路径&#x2F;index会进入IndexController类</li><li>在IndexController中指定跳转到页面index.jsp，并传递message数据</li><li>在index.jsp中显示message信息</li></ol></li></ul><h2 id="SSM"><a href="#SSM" class="headerlink" title="SSM"></a>SSM</h2><ul><li><p>由Spring, SpringMVC, Mybatis整合而成，其配置文件主要有applicationContext.xml、springMvc.xml和 web.xml</p></li><li><p>applicationContext.xml</p><pre><code class="java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xsi:schemaLocation=&quot;     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd     http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;               &lt;context:annotation-config /&gt;    &lt;context:component-scan base-package=&quot;service&quot; /&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;        &lt;!-- 基本属性 url、user、password --&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/how2java?serverTimezone=Asia/Shanghai&quot; /&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;        &lt;property name=&quot;password&quot; value=&quot;Ab711910&quot; /&gt;        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;        &lt;!-- 配置初始化大小、最小、最大 --&gt;        &lt;property name=&quot;initialSize&quot; value=&quot;3&quot; /&gt;        &lt;property name=&quot;minIdle&quot; value=&quot;3&quot; /&gt;        &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt;        &lt;!-- 配置获取连接等待超时的时间 --&gt;        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt;        &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;        &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt;        &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;        &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt;        &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT 1&quot; /&gt;        &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt;        &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt;        &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt;        &lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;        &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt;        &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;20&quot; /&gt;    &lt;/bean&gt;    &lt;!--     &lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;   --&gt;    &lt;!--       &lt;property name=&quot;driverClassName&quot;&gt;   --&gt;    &lt;!--           &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;   --&gt;    &lt;!--       &lt;/property&gt;   --&gt;    &lt;!--       &lt;property name=&quot;url&quot;&gt;   --&gt;    &lt;!--           &lt;value&gt;jdbc:mysql://localhost:3306/how2java?characterEncoding=UTF-8&lt;/value&gt;   --&gt;    &lt;!--       &lt;/property&gt;   --&gt;    &lt;!--       &lt;property name=&quot;username&quot;&gt;   --&gt;    &lt;!--           &lt;value&gt;root&lt;/value&gt;   --&gt;    &lt;!--       &lt;/property&gt;   --&gt;    &lt;!--       &lt;property name=&quot;password&quot;&gt;   --&gt;    &lt;!--           &lt;value&gt;Ab711910&lt;/value&gt;   --&gt;    &lt;!--       &lt;/property&gt;      --&gt;    &lt;!--     &lt;/bean&gt;    --&gt;    &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;pojo&quot; /&gt;        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/Category.xml&quot;/&gt;        &lt;property name=&quot;plugins&quot;&gt;            &lt;array&gt;                &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;                    &lt;property name=&quot;properties&quot;&gt;                        &lt;!--使用下面的方式配置参数，一行配置一个 --&gt;                        &lt;value&gt;                        &lt;/value&gt;                    &lt;/property&gt;                &lt;/bean&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;        &lt;property name=&quot;basePackage&quot; value=&quot;mapper&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre></li><li><p>原理：</p><ol><li><p>首先浏览器上访问路径 &#x2F;listCategory</p></li><li><p>tomcat根据web.xml上的配置信息，拦截到了&#x2F;listCategory，并将其交由DispatcherServlet处理。</p></li><li><p>DispatcherServlet 根据springMVC的配置，将这次请求交由CategoryController类进行处理，在该类的方法中会调用service目录下CategoryService类的相关方法，例如list方法。</p></li><li><p>调用对应的CategoryService方法时会调用impl目录下的CategoryServiceImpl。 </p></li><li><p>调用CategoryServiceImpl的时候，又会调用mapper目录下的CategoryMapper</p></li><li><p>根据ApplicationContext.xml中的配置信息，将CategoryMapper和Category.xml关联起来了。于是就会调用.xml文件进行SQL操作，最后返回数据</p></li><li><p>获取数据，并把数据放在”cs”上，接着服务端跳转到listCategory.jsp去</p></li><li><p>最后在listCategory.jsp 中显示数据</p></li></ol></li></ul><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><p>在SSM(H)中，需要做大量的配置工作，其实很多配置行为本身只是手段，并不是目的。 基于这个考虑，把该简化的简化，该省略的省略，开发人员只用关心提供业务功能就行了，这就是 SpringBoot。换言之，SpringBoot可以简单地看成简化了的、按照约定开发的SSM(H)。 开发速度大大提升。</p><ul><li><p>热部署：当发生了任何修改之后，必须关闭后再启动Application类才能够生效，显得略微麻烦。 Springboot提供了热部署的方式，当发现任何类发生了改变，马上通过JVM类加载的方式，加载最新的类到虚拟机中。 这样就不需要重新启动也能看到修改后的效果了</p></li><li><p>配置文件application.properties</p><pre><code class="java">#serverserver.port=8080#project pathContextPathserver.context-path=/#encodingserver.tomcat.uri-encoding=UTF-8#view prefixspring.mvc.view.prefix=/WEB-INF/jsp/#view suffixspring.mvc.view.suffix=.jsp#灵活地切换使用环境spring.profiles.active=pro#jdbcspring.datasource.url=jdbc:mysql://localhost:3306/how2java?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;zeroDateTimeBehavior=convertToNull&amp;allowMultiQueries=true&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=Ab711910spring.datasource.driver-class-name=com.mysql.jdbc.Driver#mybatismybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.csust.vo</code></pre></li><li><p>对应的yml类型的配置文件application.yml（二选一即可）</p><pre><code class="java">spring:    mvc:        view:            prefix: /WEB-INF/jsp/            suffix: .jspserver:    port: 8888    context-path: /test</code></pre></li><li><p>多配置文件：例如<br>核心配置文件：application.properties<br>开发环境用的配置文件：application-dev.properties<br>生产环境用的配置文件：application-pro.properties<br>可以通过application.properties里的spring.profiles.active 灵活地来切换使用环境</p></li><li><p>持久层支持：JPA(Java Persistence API)是Sun官方提出的Java持久化规范，用来方便大家操作数据库。<br>真正干活的可能是Hibernate,TopLink等等实现了JPA规范的不同厂商,默认是Hibernate。JPA 条件查询方式很特别，是不需要写 SQL 语句的，只需要在 dao 接口里按照规范的命名定义对应的方法名，及可达到查询相应字段的效果。</p></li><li><p>Restful风格：大在做Web开发的过程中，method常用的值是get和post. 可事实上，method值还可以是put和delete等等其他值。既然method值如此丰富，那么就可以考虑使用同一个url，但是约定不同的method来实施不同的业务，这就是Restful的基本考虑。</p><table><thead><tr><th></th><th>传统风格</th><th></th><th>Restful风格</th><th></th></tr></thead><tbody><tr><td></td><td>url</td><td>method</td><td>url</td><td>method</td></tr><tr><td>增加</td><td>&#x2F;addCategory?name&#x3D;xxx</td><td>POST</td><td>&#x2F;categories</td><td>POST</td></tr><tr><td>删除</td><td>&#x2F;deleteCategory?id&#x3D;123</td><td>GET</td><td>&#x2F;categories&#x2F;123</td><td>DELETE</td></tr><tr><td>修改</td><td>&#x2F;updateCategory?id&#x3D;123&amp;name&#x3D;yyy</td><td>POST</td><td>&#x2F;categories&#x2F;123</td><td>PUT</td></tr><tr><td>获取</td><td>&#x2F;getCategory?id&#x3D;123</td><td>GET</td><td>&#x2F;categories&#x2F;123</td><td>GET</td></tr><tr><td>查询</td><td>&#x2F;listCategory</td><td>GET</td><td>&#x2F;categories</td><td>GET</td></tr></tbody></table></li><li><p>thymeleaf：thymeleaf 跟 JSP 一样，运行之后，就得到纯 HTML了。 区别在与，不运行之前， thymeleaf 也是纯 html 。所以 thymeleaf 不需要服务端的支持，就能够以 html 的方式打开，这样方便前端人员独立设计与调试, jsp 则不行，不启动服务器 jsp 没法运行出结果。thymeleaf 可以配合 Servlet 运行，但是比较常见的是配合 springboot 来运行。 当然本质上也是配合springboot 里的 springmvc 来运行的。</p></li></ul><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><ul><li><p>单体架构系统：所谓的单体架构就是所有功能都放在一个应用里。单体架构系统有其好处，如便于开发，测试，部署也很方便（直接打成一个 jar 或者 war）。不过单体架构也有其弊端，最主要体现在高访问，高并发的上限是固定的。 比如一个单体架构，能够承受 1000次访问&#x2F;秒。 但是访问量达到 2000次&#x2F;秒的时候，就会非常卡顿，严重影响业务，并且仅仅依靠单体架构本身，很难突破这个瓶颈。 解决办法通常就是采用分布式和集群来做。</p></li><li><p>微服务：简单说，一个 springboot 就是一个 微服务，并且这个 springboot 做的事情很单纯。</p></li><li><p>微服务注册中心( eureka server)：管理微服务以及微服务之间的通信。在 springcloud中，微服务注册中心叫做 eureka server, 通过它把就可以把微服务注册起来，以供将来调用。</p><p>例如，在业务逻辑上， 视图微服务需要数据微服务的数据，所以就存在一个微服务访问另一个微服务的需要。而这俩微服务已经被注册中心管理起来了，所以视图微服务就可以通过注册中心定位并访问数据微服务了。原来是在一个 springboot里就完成的事情，现在分布在多个 springboot里做，这就是初步具备分布式雏形了。<br>分布式的好处：</p><ol><li>如果更新数据微服务，视图微服务是不受影响的</li><li>可以让不同的团队开发不同的微服务，他们之间只要约定好接口，彼此之间是低耦合的。</li><li>如果视图微服务挂了，数据微服务依然可以继续使用</li></ol></li><li><p>集群：原来数据微服务只有这一个springboot, 现在做同样数据微服务的，有两个 springboot, 他们提供的功能一模一样，只是端口不一样，这样就形成了集群。<br>集群的好处：</p><ol><li>比起一个 springboot, 两个springboot 可以分别部署在两个不同的机器上，那么理论上来说，能够承受的负载就是 x 2. 这样系统就具备通过横向扩展而提高性能的机制。</li><li>如果 8001 挂了，还有 8002 继续提供微服务，这就叫做高可用 。</li></ol><p><img src="https://how2j.cn/img/site/step/9321.png" alt="img"></p></li><li><p>SpringCloud 就是一套工具，通过它可以很容易地搭建出一个集群和分布式的架子出来。springcloud 是由多个微服务组成的，即多个springboot项目组成。 而这些 springboot 之间又是围绕一个共同目的而存在的。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;  省去JDBC</summary>
      
    
    
    
    <category term="java" scheme="http://haolei56.github.io/categories/java/"/>
    
    
    <category term="java" scheme="http://haolei56.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hexo发布</title>
    <link href="http://haolei56.github.io/2022/121916107.html"/>
    <id>http://haolei56.github.io/2022/121916107.html</id>
    <published>2022-12-19T13:28:21.324Z</published>
    <updated>2022-03-27T03:36:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="使用说明" scheme="http://haolei56.github.io/categories/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    
    
    <category term="Hexo" scheme="http://haolei56.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Markdown入门</title>
    <link href="http://haolei56.github.io/2022/032712680.html"/>
    <id>http://haolei56.github.io/2022/032712680.html</id>
    <published>2022-03-27T03:42:54.000Z</published>
    <updated>2022-03-27T03:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-代码块"><a href="#1-代码块" class="headerlink" title="1.代码块"></a>1.代码块</h2><pre><code class="Java">//java代码块：~~~javaint a=1;System.out.println(a);</code></pre><h2 id="2-标题"><a href="#2-标题" class="headerlink" title="2.标题"></a>2.标题</h2><pre><code class="java">//标题语法# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="3-字体"><a href="#3-字体" class="headerlink" title="3.字体"></a>3.字体</h2><pre><code class="java">//加粗：**加粗字体**//代码高亮显示：==高亮字体==//删除线：~~被删除的文字~~//斜体：*斜体内容*</code></pre><h2 id="4-引号"><a href="#4-引号" class="headerlink" title="4.引号"></a>4.引号</h2><pre><code class="java">//引用语法：&gt;&gt;作者：郝磊&gt;&gt;作者：郝磊</code></pre><h2 id="5-分割线"><a href="#5-分割线" class="headerlink" title="5.分割线"></a>5.分割线</h2><pre><code class="java">//分割线：---(部分)或者***（全屏）</code></pre><h2 id="6-图片插入"><a href="#6-图片插入" class="headerlink" title="6.图片插入"></a>6.图片插入</h2><pre><code class="java">//在线图片或者本地图片：![给图片取得名字](图片路径)</code></pre><p><img src="D:\how2j\img\teemo.jpg" alt="提莫"></p><h2 id="7-超链接"><a href="#7-超链接" class="headerlink" title="7.超链接"></a>7.超链接</h2><pre><code class="java">//超链接：[超链接文字](超链接网址)</code></pre><h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8.列表"></a>8.列表</h2><pre><code class="java">//无序列表：- 名称1- 名称2//有序列表：1.回车</code></pre><h2 id="9-表格"><a href="#9-表格" class="headerlink" title="9.表格"></a>9.表格</h2><pre><code class="java">//表格：鼠标右键-&gt;插入-&gt;表格</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-代码块&quot;&gt;&lt;a href=&quot;#1-代码块&quot; class=&quot;headerlink&quot; title=&quot;1.代码块&quot;&gt;&lt;/a&gt;1.代码块&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;Java&quot;&gt;//java代码块：~~~java
int a=1;
System.out</summary>
      
    
    
    
    <category term="使用说明" scheme="http://haolei56.github.io/categories/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    
    
    <category term="Markdown" scheme="http://haolei56.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
